# 微商城后端项目功能实现分析文档

## 1. 项目架构概述

### 1.1 技术栈
- 基础框架：Spring Boot
- 数据访问：MyBatis Plus
- 数据库：MySQL
- 缓存：Redis
- 安全框架：Spring Security
- 接口文档：Swagger
- 工具库：Hutool、Lombok

### 1.2 项目结构
- 控制层(Controller)：接口定义和请求处理
- 服务层(Service)：业务逻辑实现
- 数据访问层(Mapper)：数据库操作
- 实体层(Entity)：数据模型定义
- 工具类(Utils)：通用工具方法
- 配置类(Config)：项目配置

## 2. 功能模块实现

### 2.1 用户模块
- 功能实现：
  - 用户注册
  - 用户登录
  - 信息修改
  - 密码重置
- 技术要点：
  - JWT认证
  - 密码加密
  - 会话管理
  - 权限控制

### 2.2 商品模块
- 功能实现：
  - 商品管理
  - 分类管理
  - 库存管理
  - 搜索功能
- 技术要点：
  - 缓存优化
  - 库存锁定
  - 搜索引擎
  - 图片处理

### 2.3 订单模块
- 功能实现：
  - 订单创建
  - 订单支付
  - 订单取消
  - 订单查询
- 技术要点：
  - 事务管理
  - 状态机制
  - 支付集成
  - 库存扣减

### 2.4 购物车模块
- 功能实现：
  - 添加商品
  - 修改数量
  - 删除商品
  - 清空购物车
- 技术要点：
  - Redis缓存
  - 数据同步
  - 库存检查
  - 价格计算

### 2.5 支付模块
- 功能实现：
  - 支付集成
  - 支付回调
  - 支付状态查询
- 技术要点：
  - 支付集成
  - 支付回调
  - 支付状态查询

### 2.6 分类模块
- 功能实现：
  - 分类管理
  - 分类查询
  - 分类树形结构
- 技术要点：
  - 缓存设计
  - 树形结构构建
  - 并发控制

## 3. 数据库设计

### 3.1 核心表结构
- 用户表(user)
  - 基本信息
  - 账号信息
  - 安全信息
  - 状态信息
- 商品表(product)
  - 基本信息
  - 价格信息
  - 库存信息
  - 分类信息
- 订单表(order)
  - 订单信息
  - 支付信息
  - 配送信息
  - 状态信息
- 购物车表(cart)
  - 商品信息
  - 数量信息
  - 用户信息
  - 选择状态
- 支付表(payment)
  - 支付流水号
  - 订单ID
  - 订单编号
  - 用户ID
  - 支付方式
  - 第三方交易号
  - 支付金额
  - 支付状态
  - 支付时间
  - 创建时间
  - 更新时间
- 支付日志表(payment_log)
  - 支付流水号
  - 日志类型
  - 日志内容
  - 创建时间

### 3.2 关联关系
- 一对多关系：
  - 用户-订单
  - 用户-购物车
  - 分类-商品
- 多对多关系：
  - 订单-商品
  - 用户-商品(收藏)
  - 用户-地址

## 4. 接口设计

### 4.1 RESTful API
- 接口规范：
  - URL设计
  - 请求方法
  - 状态码
  - 返回格式
- 接口文档：
  - Swagger配置
  - 接口说明
  - 参数说明
  - 响应说明

### 4.2 接口安全
- 安全措施：
  - Token验证
  - 权限控制
  - 参数校验
  - 防重放
- 数据安全：
  - 数据加密
  - 敏感信息处理
  - XSS防护
  - SQL注入防护

## 5. 性能优化

### 5.1 数据库优化
- 索引优化：
  - 主键索引
  - 普通索引
  - 联合索引
  - 覆盖索引
- 查询优化：
  - SQL优化
  - 分页优化
  - 连接优化
  - 缓存优化

### 5.2 缓存设计
- 缓存策略：
  - 热点数据
  - 查询缓存
  - 会话缓存
  - 页面缓存
- 缓存管理：
  - 缓存更新
  - 缓存失效
  - 缓存同步
  - 缓存穿透

### 5.3 并发处理
- 并发控制：
  - 乐观锁
  - 悲观锁
  - 分布式锁
  - 库存锁定
- 限流措施：
  - 接口限流
  - 用户限流
  - 服务限流
  - 降级处理

## 6. 项目部署

### 6.1 环境配置
- 开发环境：
  - 本地开发
  - 测试环境
  - 预发布环境
  - 生产环境
- 配置管理：
  - 配置文件
  - 环境变量
  - 密钥管理
  - 日志配置

### 6.2 部署方案
- 服务部署：
  - 应用部署
  - 数据库部署
  - 缓存部署
  - 负载均衡
- 监控运维：
  - 性能监控
  - 日志监控
  - 异常监控
  - 业务监控

## 7. 项目依赖分析

### 7.1 核心依赖
- Spring Boot相关：
  - spring-boot-starter-web：Web应用支持
  - spring-boot-starter-test：测试支持
  - spring-boot-starter-validation：参数校验
- 数据库相关：
  - mysql-connector-java：MySQL驱动
  - mybatis-plus-boot-starter：MyBatis Plus支持
- 安全相关：
  - spring-security-crypto：加密工具
  - jjwt：JWT支持
  - bcprov-jdk15on：加密算法库

### 7.2 支付集成
- 支付宝支持：
  - alipay-easysdk：支付宝SDK
  - alipay-sdk-java：支付宝开发包
- 微信支付：
  - wechatpay-apache-httpclient：微信支付SDK
  - httpclient：HTTP客户端
  - httpcore：HTTP核心组件

### 7.3 工具依赖
- 开发工具：
  - lombok：代码简化
  - jackson-databind：JSON处理
  - commons-io：IO工具
- 加密安全：
  - bcpkix-jdk15on：PKI支持
  - bcutil-jdk15on：加密工具
  - bouncycastle：加密库

## 8. 项目配置分析

### 8.1 基础配置
- 服务器配置：
  - 服务端口
  - 上下文路径
  - 编码设置
  - 会话配置
- 数据源配置：
  - 数据库连接
  - 连接池设置
  - 事务配置
  - MyBatis配置

### 8.2 安全配置
- JWT配置：
  - 密钥设置
  - 过期时间
  - Token配置
  - 刷新策略
- 安全策略：
  - 密码加密
  - 跨域设置
  - 安全过滤
  - 权限配置

### 8.3 支付配置
- 支付宝配置：
  - 应用ID
  - 商户私钥
  - 支付宝公钥
  - 回调地址
- 微信支付：
  - 商户ID
  - API密钥
  - 证书配置
  - 回调配置

### 8.4 其他配置
- 文件上传：
  - 上传路径
  - 大小限制
  - 文件类型
  - 访问URL
- 缓存配置：
  - Redis连接
  - 缓存策略
  - 过期时间
  - 序列化

## 9. 开发规范

### 9.1 代码规范
- 命名规范：
  - 包命名
  - 类命名
  - 方法命名
  - 变量命名
- 注释规范：
  - 类注释
  - 方法注释
  - 字段注释
  - 接口文档

### 9.2 异常处理
- 异常设计：
  - 异常体系
  - 错误码
  - 异常转换
  - 全局处理
- 日志记录：
  - 日志级别
  - 日志格式
  - 日志切面
  - 日志归档

### 9.3 数据校验
- 参数校验：
  - 注解校验
  - 业务校验
  - 自定义校验
  - 统一处理
- 数据安全：
  - 输入过滤
  - 输出转义
  - 敏感信息
  - 数据脱敏

## 10. 测试规范

### 10.1 单元测试
- 测试范围：
  - 服务层测试
  - DAO层测试
  - 工具类测试
  - 接口测试
- 测试规范：
  - 测试命名
  - 测试覆盖
  - 断言使用
  - 测试隔离

### 10.2 集成测试
- 测试环境：
  - 数据库
  - 缓存
  - 第三方服务
  - 测试数据
- 测试场景：
  - 业务流程
  - 接口调用
  - 并发测试
  - 性能测试

## 11. 业务代码实现

### 11.1 订单模块实现
- 接口设计：
  - 创建订单
    - 参数校验
    - 库存检查
    - 价格计算
    - 订单生成
  - 订单查询
    - 分页查询
    - 状态过滤
    - 订单详情
    - 列表展示
  - 订单操作
    - 订单支付
    - 订单取消
    - 确认收货
    - 订单发货
- 实现细节：
  - 异常处理
  - 日志记录
  - 参数验证
  - 返回封装

### 11.2 支付模块实现
- 支付宝支付：
  - �����口设计
    - 支付通知
    - 同步回调
    - 签名验证
    - 订单处理
  - 实现细节
    - 参数解析
    - 签名校验
    - 状态更新
    - 异常处理
- 微信支付：
  - 接口设计
    - 统一下单
    - 支付通知
    - 订单查询
    - 退款处理
  - 实现细节
    - 参数组装
    - 安全验证
    - 结果处理
    - 日志记录

### 11.3 购物车模块实现
- 功能设计：
  - 添加商品
    - 参数校验
    - 库存检查
    - 数量更新
    - 价格计算
  - 购物车管理
    - 商品列表
    - 数量修改
    - 商品删除
    - 清空购物车
- 数据处理：
  - 数据同步
  - 缓存处理
  - 价格计算
  - 状态管理

### 11.4 商品模块实现
- 基础功能：
  - 商品管理
    - 商品添加
    - 商品修改
    - 商品下架
    - 库存管理
  - 商品查询
    - 分类查询
    - 关键词搜索
    - 条件筛选
    - 排序功能
- 高级功能：
  - 商品推荐
  - 热销商品
  - 新品上架
  - 促销活动

## 12. 数据库实现

### 12.1 表结构设计
- 用户相关：
  - 用户表(user)
    - 基本字段
    - 索引设计
    - 关联关系
    - 约束条件
  - 地址表(address)
    - 地址信息
    - 默认标识
    - 用户关联
    - 排序字段
- 商品相关：
  - 商品表(product)
    - 基本信息
    - 价格库存
    - 分类关联
    - 状态标识
  - 分类表(category)
    - 分类信息
    - 层级关系
    - 排序字段
    - 状态标识

### 12.2 订单设计
- 订单主表：
  - 基本信息
    - 订单编号
    - 用户信息
    - 支付信息
    - 收货信息
  - 状态信息
    - 订单状态
    - 支付状态
    - 发货状态
    - 完成状态
- 订单明细：
  - 商品信息
    - 商品ID
    - 商品名称
    - 商品图片
    - 商品规格
  - 价格信息
    - 商品价格
    - 购买数量
    - 优惠金额
    - 实付金额

### 12.3 支付设计
- 支付记录：
  - 基本信息
    - 支付流水号
    - 订单信息
    - 支付方式
    - 支付金额
  - 状态信息
    - 支付状态
    - 回调状态
    - 退款状态
    - 完成状态
- 退款记录：
  - 退款信息
    - 退款单号
    - 支付信息
    - 退款金额
    - 退款原因
  - 处理信息
    - 申请时间
    - 处理时间
    - 处理状态
    - 处理结果

## 13. 代码实现细节

### 13.1 实体类设计
- 用户相关：
  - User.java
    - 用户基本信息
    - 账号密码
    - 状态标识
    - 创建时间
  - Category.java
    - 分类名称
    - 父级ID
    - 排序字段
    - 状态标识
- 商品相关：
  - Product.java
    - 商品信息
    - 价格库存
    - 分类关联
    - 状态管理
  - Cart.java
    - 购物车信息
    - 商品关联
    - 数量价格
    - 选择状态
- 订单相关：
  - Order.java
    - 订单基本信息
    - 支付信息
    - 状态管理
    - 时间管理
  - OrderItem.java
    - 订单商品信息
    - 数量价格
    - 商品快照
    - 订单关联
- 支付相关：
  - Payment.java
    - 支付流水信息
    - 支付方式
    - 支付状态
    - 回调信息
  - PaymentLog.java
    - 支付日志
    - 操作记录
    - 状态变更
    - 时间记录

### 13.2 服务层实现
- 用户服务：
  - UserServiceImpl.java
    - 用户注册
    - 用户登录
    - 信息修改
    - 密码重置
  - CategoryServiceImpl.java
    - 分类管理
    - 层级处理
    - 排序维护
    - 状态管理
- 商品服务：
  - ProductServiceImpl.java
    - 商品CRUD
    - 库存管理
    - 搜索功能
    - 分类关联
  - CartServiceImpl.java
    - 购物车管理
    - 数量修改
    - 价格计算
    - 选择状态
- 订单服务：
  - OrderServiceImpl.java
    - 订单创建
    - 订单查询
    - 状态管理
    - 订单操作
  - OrderItemServiceImpl.java
    - 订单明细
    - 商品关联
    - 价格计算
    - 库存处理
- 支付服务：
  - PaymentServiceImpl.java
    - 支付处理
    - 状态管理
    - 回调处理
    - 日志记录
  - AlipayServiceImpl.java
    - 支付宝支付
    - 回调处理
    - 签名验证
    - 订单处理
  - WechatPayServiceImpl.java
    - 微信支付
    - 统一下单
    - 回调处理
    - 退款处理

### 13.3 控制层实现
- 用户接口：
  - UserController.java
    - 注册接口
    - 登录接口
    - 信息修改
    - 密码重置
  - CategoryController.java
    - 分类列表
    - 分类添加
    - 分类修改
    - 分类删除
- 商品接口：
  - ProductController.java
    - 商品管理
    - 商品查询
    - 库存管理
    - 分类关联
  - CartController.java
    - 购物车管理
    - 商品操作
    - 数量修改
    - 选择状态
- 订单接口：
  - OrderController.java
    - 订单创建
    - 订单查询
    - 订单操作
    - 状态管理
  - PaymentController.java
    - 支付处理
    - 支付查询
    - 退款处理
    - 日志查询
- 支付接口：
  - AlipayController.java
    - 支付接口
    - 回调接口
    - 查询接口
    - 退款接口
  - WechatPayController.java
    - 统一下单
    - 支付通知
    - 订单查询
    - 退款处理

### 13.4 数据访问层
- 用户相关：
  - UserMapper.java
    - 用户CRUD
    - 条件查询
    - 状态更新
    - 关联查询
  - CategoryMapper.java
    - 分类管理
    - 层级查询
    - 关联查询
    - 排序处理
- 商品相关：
  - ProductMapper.java
    - 商品管理
    - 库存操作
    - 条件查询
    - 分类关联
  - CartMapper.java
    - 购物车操作
    - 商品关联
    - 数量更新
    - 状态管理
- 订单相关：
  - OrderMapper.java
    - 订单管理
    - 状态查询
    - 关联查询
    - 统计分析
  - OrderItemMapper.java
    - 订单明细
    - 商品关联
    - 批量操作
    - 统计查询
- 支付相关：
  - PaymentMapper.java
    - 支付记录
    - 状态更新
    - 关联查询
    - 统计分析
  - PaymentLogMapper.java
    - 日志记录
    - 操作记录
    - 状态记录
    - 查询统计

## 14. 核心业务代码实现

### 14.1 订单创建流程
- OrderServiceImpl.java：
  ```java
  @Transactional
  public OrderDTO create(Long userId, List<Long> cartIds) {
      // 1. 获取购物车商品
      List<Cart> cartList = getCartList(userId, cartIds);
      
      // 2. 检查商品库存
      checkStock(cartList);
      
      // 3. 计算订单总金额
      BigDecimal totalAmount = calculateTotalAmount(cartList);
      
      // 4. 创建订单
      Order order = createOrder(userId, totalAmount);
      
      // 5. 创建订单项
      List<OrderItem> orderItems = createOrderItems(order.getId(), cartList);
      
      // 6. 更新商品库存和销量
      updateProductStock(cartList);
      
      // 7. 清空购物车
      clearCart(userId, cartIds);
      
      // 8. 返回订单信息
      return convertToDTO(order, orderItems);
  }
  ```

### 14.2 订单状态管理
- 状态定义：
  ```java
  public enum OrderStatus {
      UNPAID(0, "待付款"),
      PAID(1, "待发货"),
      SHIPPED(2, "待收货"),
      COMPLETED(3, "已完成"),
      CANCELLED(4, "已取消");
  }
  ```
- 状态流转：
  ```java
  // 支付订单
  @Transactional
  public void pay(Long orderId) {
      Order order = orderMapper.selectById(orderId);
      checkOrderExists(order);
      checkOrderStatus(order, OrderStatus.UNPAID);
      
      order.setStatus(OrderStatus.PAID.getValue());
      order.setPayTime(new Date());
      orderMapper.updateById(order);
  }
  
  // 取消订单
  @Transactional
  public void cancel(Long orderId) {
      Order order = orderMapper.selectById(orderId);
      checkOrderExists(order);
      checkOrderCanCancel(order);
      
      order.setStatus(OrderStatus.CANCELLED.getValue());
      restoreStock(order);
      orderMapper.updateById(order);
  }
  ```

### 14.3 支付集成实现
- 支付宝支付：
  ```java
  @RestController
  @RequestMapping("/api/payment/alipay")
  public class AlipayController {
      // 支付回调
      @PostMapping("/notify")
      public String notify(HttpServletRequest request) {
          // 1. 获取支付宝回调参数
          Map<String, String> params = getParams(request);
          
          // 2. 验证签名
          if (verifySignature(params)) {
              // 3. 验证订单状态
              String tradeStatus = params.get("trade_status");
              if ("TRADE_SUCCESS".equals(tradeStatus)) {
                  // 4. 处理支付成功
                  handlePaymentSuccess(params);
                  return "success";
              }
          }
          return "fail";
      }
  }
  ```

### 14.4 购物车实现
- 添加商品：
  ```java
  @Transactional
  public void addToCart(Long userId, Long productId, Integer quantity) {
      // 1. 检查商品
      Product product = checkProduct(productId);
      
      // 2. 检查库存
      checkStock(product, quantity);
      
      // 3. 查找购物车中是否已存在
      Cart cart = findCartItem(userId, productId);
      
      // 4. 更新或创建
      if (cart != null) {
          updateCartItem(cart, quantity);
      } else {
          createCartItem(userId, product, quantity);
      }
  }
  ```

### 14.5 商品搜索实现
- 条件查询：
  ```java
  public Page<ProductDTO> search(ProductSearchRequest request) {
      // 1. 构建查询条件
      QueryWrapper<Product> wrapper = new QueryWrapper<>();
      buildSearchCondition(wrapper, request);
      
      // 2. 执行分页查询
      Page<Product> page = productMapper.selectPage(
          new Page<>(request.getPageNum(), request.getPageSize()),
          wrapper
      );
      
      // 3. 转换结果
      return convertToDTO(page);
  }
  ```

### 14.6 用户认证实现
- JWT认证：
  ```java
  @Component
  public class JwtTokenProvider {
      // 生成Token
      public String generateToken(UserDetails userDetails) {
          Map<String, Object> claims = new HashMap<>();
          return createToken(claims, userDetails.getUsername());
      }
      
      // 验证Token
      public boolean validateToken(String token, UserDetails userDetails) {
          String username = extractUsername(token);
          return (username.equals(userDetails.getUsername()) && !isTokenExpired(token));
      }
  }
  ```

### 14.7 异常处理实现
- 全局异常处理：
  ```java
  @RestControllerAdvice
  public class GlobalExceptionHandler {
      // 业务异常
      @ExceptionHandler(BusinessException.class)
      public Result handleBusinessException(BusinessException e) {
          log.error("业务异常：", e);
          return Result.error(e.getCode(), e.getMessage());
      }
      
      // 系统异常
      @ExceptionHandler(Exception.class)
      public Result handleException(Exception e) {
          log.error("系统异常：", e);
          return Result.error("系统异常，请稍后重试");
      }
  }
  ```

### 14.8 数据验证实现
- 参数校验：
  ```java
  @Data
  public class OrderCreateRequest {
      @NotNull(message = "用户ID不能为空")
      private Long userId;
      
      @NotEmpty(message = "购物车ID不能为空")
      private List<Long> cartIds;
      
      @Valid
      private AddressDTO address;
  }
  ```
- 业务校验：
  ```java
  public void checkStock(List<Cart> cartList) {
      for (Cart cart : cartList) {
          Product product = productMapper.selectById(cart.getProductId());
          if (product == null || product.getStock() < cart.getQuantity()) {
              throw new BusinessException("商品库存不足");
          }
      }
  }
  ```

## 15. 订单模块实现

### 15.1 订单相关文件
- 实体类：
  - Order.java：订单实体类
  - OrderItem.java：订单项实体类
- 数据访问层：
  - OrderMapper.java：订单数据访问接口
  - OrderItemMapper.java：订单项数据访问接口
- 服务层：
  - OrderService.java：订单服务接口
  - OrderServiceImpl.java：订单服务实现类
- 控制层：
  - OrderController.java：订单控制器

### 15.2 订单创建流程
- OrderController.java：
  ```java
  @PostMapping("/create")
  public Result<OrderDTO> create(@RequestBody @Valid OrderCreateRequest request) {
      try {
          OrderDTO order = orderService.create(request.getUserId(), request.getCartIds());
          return Result.success(order);
      } catch (Exception e) {
          return Result.error(e.getMessage());
      }
  }
  ```

- OrderServiceImpl.java：
  ```java
  @Transactional
  public OrderDTO create(Long userId, List<Long> cartIds) {
      // 1. 获取购物车商品
      List<Cart> cartList = getCartList(userId, cartIds);
      
      // 2. 检查商品库存
      checkStock(cartList);
      
      // 3. 计算订单总金额
      BigDecimal totalAmount = calculateTotalAmount(cartList);
      
      // 4. 创建订单
      Order order = createOrder(userId, totalAmount);
      
      // 5. 创建订单项
      List<OrderItem> orderItems = createOrderItems(order.getId(), cartList);
      
      // 6. 更新商品库存和销量
      updateProductStock(cartList);
      
      // 7. 清空购物车
      clearCart(userId, cartIds);
      
      return convertToDTO(order, orderItems);
  }
  ```

## 16. 支付模块实现

### 16.1 支付相关文件
- 实体类：
  - Payment.java：支付实体类
  - PaymentLog.java：支付日志实体类
- 数据访问层：
  - PaymentMapper.java：支付数据访问接口
  - PaymentLogMapper.java：支付日志数据访问接口
- 服务层：
  - PaymentService.java：支付服务接口
  - PaymentServiceImpl.java：支付服务实现类
  - AlipayServiceImpl.java：支付宝支付实现
  - WechatPayServiceImpl.java：微信支付实现
- 控制层：
  - PaymentController.java：支付控制器
  - AlipayController.java：支付宝支付控制器

### 16.2 支付宝支付实现
- AlipayController.java：
  ```java
  @PostMapping("/notify")
  public String notify(HttpServletRequest request) {
      try {
          // 1. 获取支付宝回调参数
          Map<String, String> params = getParams(request);
          
          // 2. 验证签名
          if (verifySignature(params)) {
              // 3. 验证订单状态
              String tradeStatus = params.get("trade_status");
              if ("TRADE_SUCCESS".equals(tradeStatus)) {
                  // 4. 处理支付成功
                  handlePaymentSuccess(params);
                  return "success";
              }
          }
          return "fail";
      } catch (Exception e) {
          log.error("处理支付宝回调异常", e);
          return "fail";
      }
  }
  ```

## 17. 购物车模块实现

### 17.1 购物车相关文件
- 实体类：
  - Cart.java：购物车实体类
- 数据访问层：
  - CartMapper.java：购物车数据访问接口
- 服务层：
  - CartService.java：购物车服务接口
  - CartServiceImpl.java：购物车服务实现类
- 控制层：
  - CartController.java：购物车控制器

### 17.2 购物车功能实现
- CartController.java：
  ```java
  @PostMapping("/add")
  public Result<Cart> add(@RequestBody CartAddRequest request) {
      try {
          Cart cart = cartService.add(request.getUserId(), request.getProductId(), request.getQuantity());
          return Result.success(cart);
      } catch (Exception e) {
          return Result.error(e.getMessage());
      }
  }
  ```

### 17.3 购物车核心功能实现
- CartServiceImpl.java：
  ```java
  @Service
  @Slf4j
  public class CartServiceImpl implements CartService {
      @Autowired
      private CartMapper cartMapper;
      
      @Autowired
      private ProductMapper productMapper;
      
      @Override
      @Transactional
      public CartDTO add(Long userId, Long productId, Integer quantity) {
          // 1. 检查商品是否存在
          Product product = productMapper.selectById(productId);
          if (product == null) {
              throw new RuntimeException("商品不存在");
          }
          
          // 2. 检查库存
          if (product.getStock() < quantity) {
              throw new RuntimeException("商品库存不足");
          }
          
          // 3. 查询购物车中是否已存在
          QueryWrapper<Cart> wrapper = new QueryWrapper<>();
          wrapper.eq("user_id", userId)
                 .eq("product_id", productId);
          Cart cart = cartMapper.selectOne(wrapper);
          
          if (cart != null) {
              // 4. 更新数量
              cart.setQuantity(cart.getQuantity() + quantity);
              cart.setUpdateTime(LocalDateTime.now());
              cartMapper.updateById(cart);
          } else {
              // 5. 新增购物车记录
              cart = new Cart();
              cart.setUserId(userId);
              cart.setProductId(productId);
              cart.setQuantity(quantity);
              cart.setSelected(true);
              cart.setCreateTime(LocalDateTime.now());
              cart.setUpdateTime(LocalDateTime.now());
              cartMapper.insert(cart);
          }
          
          return convertToDTO(cart, product);
      }
      
      @Override
      public List<CartDTO> list(Long userId) {
          List<CartDTO> cartDTOs = cartMapper.selectCartDTOList(userId);
          // 计算每个商品的总价
          cartDTOs.forEach(cart -> {
              cart.setTotalPrice(cart.getProductPrice()
                  .multiply(new BigDecimal(cart.getQuantity())));
          });
          return cartDTOs;
      }
  }
  ```

### 17.4 购物车数据表结构
- cart表：
  ```sql
  CREATE TABLE `cart` (
    `id` bigint(20) NOT NULL AUTO_INCREMENT,
    `user_id` bigint(20) NOT NULL COMMENT '用户ID',
    `product_id` bigint(20) NOT NULL COMMENT '商品ID',
    `quantity` int(11) NOT NULL COMMENT '数量',
    `selected` tinyint(4) NOT NULL DEFAULT '1' COMMENT '是否选中：0-未选中，1-已选中',
    `create_time` datetime NOT NULL COMMENT '创建时间',
    `update_time` datetime NOT NULL COMMENT '更新时间',
    PRIMARY KEY (`id`),
    KEY `idx_user_id` (`user_id`),
    KEY `idx_product_id` (`product_id`)
  ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='购物车表';
  ```

### 17.5 购物车接口说明
1. 添加商品到购物车
   - 请求路径：POST /api/cart/add
   - 请求参数：
     ```json
     {
       "userId": "用户ID",
       "productId": "商品ID",
       "quantity": "数量"
     }
     ```
   - 业务逻辑：
     1. 检查商品是否存在
     2. 检查商品库存是否充足
     3. 查询购物车是否已存在该商品
     4. 如果存在则更新数量，不存在则新增记录
     5. 返回购物车商品信息

2. 查询购物车列表
   - 请求路径：GET /api/cart/list
   - 请求参数：userId
   - 业务逻辑：
     1. 查询用户的购物车商品列表
     2. 关联查询商品信息
     3. 计算每个商品的总价
     4. 返回购物车列表数据

3. 更新购物车商品数量
   - 请求路径：PUT /api/cart/update
   - 请求参数：
     ```json
     {
       "userId": "用户ID",
       "productId": "商品ID",
       "quantity": "数量"
     }
     ```
   - 业务逻辑：
     1. 检查商品是否存在
     2. 检查商品库存是否充足
     3. 更新购物车商品数量

4. 删除购物车商品
   - 请求路径：DELETE /api/cart/delete
   - 请求参数：userId, productId
   - 业务逻辑：
     1. 根据用户ID和商品ID删除购物车记录

5. 更新商品选中状态
   - 请求路径：PUT /api/cart/selected
   - 请求参数：
     ```json
     {
       "userId": "用户ID",
       "productId": "商品ID",
       "selected": "是否选中"
     }
     ```
   - 业务逻辑：
     1. 更新购物车商品的选中状态

## 18. 商品模块实现

### 18.1 商品相关文件
- 实体类：
  - Product.java：商品实体类
  - Category.java：分类实体类
- 数据访问层：
  - ProductMapper.java：商品数据访问接口
  - CategoryMapper.java：分类数据访问接口
- 服务层：
  - ProductService.java：商品服务接口
  - ProductServiceImpl.java：商品服务实现类
  - CategoryService.java：分类服务接口
  - CategoryServiceImpl.java：分类服务实现类
- 控制层：
  - ProductController.java：商品控制器
  - CategoryController.java：分类控制器

### 18.2 商品查询实现
- ProductMapper.java：
  ```java
  @Mapper
  public interface ProductMapper extends BaseMapper<Product> {
      Page<Product> selectProductPage(Page<Product> page, 
                                    @Param("categoryId") Long categoryId,
                                    @Param("keyword") String keyword,
                                    @Param("status") Integer status);
  }
  ```

### 18.3 商品核心功能实现
- ProductServiceImpl.java：
  ```java
  @Service
  public class ProductServiceImpl implements ProductService {
      @Autowired
      private ProductMapper productMapper;
      
      @Autowired
      private CategoryMapper categoryMapper;
      
      @Override
      public Page<ProductDTO> list(ProductSearchDTO searchDTO) {
          Page<Product> page = new Page<>(searchDTO.getPageNum(), searchDTO.getPageSize());
          
          // 1. 使用自定义查询方法
          Page<Product> productPage = productMapper.searchProducts(
              page, 
              searchDTO.getCategoryId(),
              searchDTO.getKeyword(),
              searchDTO.getOrderBy()
          );
          
          // 2. 获取所有分类并创建映射
          Map<Long, String> categoryMap = categoryMapper.selectList(null)
                  .stream()
                  .collect(Collectors.toMap(
                      Category::getId,
                      Category::getName,
                      (existing, replacement) -> existing
                  ));
          
          // 3. 转换为DTO
          Page<ProductDTO> dtoPage = new Page<>();
          BeanUtils.copyProperties(productPage, dtoPage, "records");
          
          List<ProductDTO> dtoList = productPage.getRecords().stream().map(product -> {
              ProductDTO dto = new ProductDTO();
              BeanUtils.copyProperties(product, dto);
              dto.setCategoryName(categoryMap.getOrDefault(product.getCategoryId(), "未知分类"));
              return dto;
          }).collect(Collectors.toList());
          
          dtoPage.setRecords(dtoList);
          return dtoPage;
      }
  }
  ```

### 18.4 商品查询SQL实现
- ProductMapper.xml：
  ```xml
  <mapper namespace="com.mall.mapper.ProductMapper">
      <select id="searchProducts" resultType="com.mall.entity.Product">
          SELECT p.*, c.name as category_name
          FROM product p
          LEFT JOIN category c ON p.category_id = c.id
          WHERE p.status = 1
          <if test="categoryId != null">
              AND p.category_id = #{categoryId}
          </if>
          <if test="keyword != null and keyword != ''">
              AND (
                  p.name LIKE CONCAT('%', #{keyword}, '%')
                  OR p.description LIKE CONCAT('%', #{keyword}, '%')
                  OR c.name LIKE CONCAT('%', #{keyword}, '%')
              )
          </if>
          <choose>
              <when test="orderBy == 'price_asc'">
                  ORDER BY p.price ASC
              </when>
              <when test="orderBy == 'price_desc'">
                  ORDER BY p.price DESC
              </when>
              <when test="orderBy == 'sales_desc'">
                  ORDER BY p.sales DESC
              </when>
              <otherwise>
                  ORDER BY p.create_time DESC
              </otherwise>
          </choose>
      </select>
  </mapper>
  ```

### 18.5 商品接口说明
1. 商品列表查询
   - 请求路径：GET /api/product/list
   - 请求参数：
     ```json
     {
       "pageNum": "页码",
       "pageSize": "每页数量",
       "categoryId": "分类ID",
       "keyword": "搜索关键词",
       "orderBy": "排序方式"
     }
     ```
   - 业务逻辑：
     1. 支持按分类查询
     2. 支持关键词搜索（商品名称、描述、分类名称）
     3. 支持多种排序方���（价格升序/降序、销量降序、最新）
     4. 返回分页数据

2. 商品详情查询
   - 请求路径：GET /api/product/detail/{id}
   - 请求参数：商品ID
   - 业务逻辑：
     1. 查询商品基本信息
     2. 关联查询分类信息
     3. 返回商品详细信息

### 18.6 商品数据表结构
- product表：
  ```sql
  CREATE TABLE `product` (
    `id` bigint(20) NOT NULL AUTO_INCREMENT,
    `name` varchar(128) NOT NULL COMMENT '商品名称',
    `category_id` bigint(20) NOT NULL COMMENT '分类ID',
    `price` decimal(10,2) NOT NULL COMMENT '价格',
    `stock` int(11) NOT NULL COMMENT '库存',
    `sales` int(11) NOT NULL DEFAULT '0' COMMENT '销量',
    `main_image` varchar(255) NOT NULL COMMENT '主图',
    `sub_images` text COMMENT '子图JSON数组',
    `description` text COMMENT '商品描述',
    `detail` text COMMENT '商品详情',
    `status` tinyint(4) NOT NULL DEFAULT '1' COMMENT '状态：0-下架，1-上架',
    `create_time` datetime NOT NULL COMMENT '创建时间',
    `update_time` datetime NOT NULL COMMENT '更新时间',
    PRIMARY KEY (`id`),
    KEY `idx_category_id` (`category_id`),
    KEY `idx_name` (`name`)
  ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='商品表';
  ```

## 19. 用户模块实现

### 19.1 用户相关文件
- 实体类：
  - User.java：用户实体类
- 数据访问层：
  - UserMapper.java：用户数据访问接口
- 服务层：
  - UserService.java：用户服务接口
  - UserServiceImpl.java：用户服务实现类
- 控制层：
  - UserController.java：用户控制器

### 19.2 用户认证实现
- UserController.java：
  ```java
  @PostMapping("/login")
  public Result<UserDTO> login(@RequestBody @Valid LoginRequest request) {
      try {
          UserDTO user = userService.login(request.getUsername(), request.getPassword());
          return Result.success(user);
      } catch (Exception e) {
          return Result.error(e.getMessage());
      }
  }
  ```

### 19.3 用户核心功能实现
- UserServiceImpl.java：
  ```java
  @Service
  public class UserServiceImpl implements UserService {
      @Autowired
      private UserMapper userMapper;
      
      private final BCryptPasswordEncoder passwordEncoder = new BCryptPasswordEncoder();
      
      @Override
      public UserDTO register(User user) {
          // 1. 检查用户名是否已存在
          QueryWrapper<User> queryWrapper = new QueryWrapper<>();
          queryWrapper.eq("username", user.getUsername());
          if (userMapper.selectOne(queryWrapper) != null) {
              throw new RuntimeException("用户名已存在");
          }
          
          // 2. 加密密码
          user.setPassword(passwordEncoder.encode(user.getPassword()));
          user.setCreateTime(LocalDateTime.now());
          user.setUpdateTime(LocalDateTime.now());
          userMapper.insert(user);
          
          // 3. 转换为DTO返回
          return convertToDTO(user);
      }
      
      @Override
      public UserDTO login(String username, String password) {
          // 1. 查询用户
          QueryWrapper<User> queryWrapper = new QueryWrapper<>();
          queryWrapper.eq("username", username);
          User user = userMapper.selectOne(queryWrapper);
          
          // 2. 验证密码
          if (user == null || !passwordEncoder.matches(password, user.getPassword())) {
              throw new RuntimeException("用户名或密码错误");
          }
          
          // 3. 返回用户信息
          return convertToDTO(user);
      }
  }
  ```

### 19.4 用户接口说明
1. 用户注册
   - 请求路径：POST /api/user/register
   - 请求参数：
     ```json
     {
       "username": "用户名",
       "password": "密码",
       "email": "邮箱",
       "phone": "手机号"
     }
     ```
   - 业务逻辑：
     1. 检查用户名是否已存在
     2. 对密码进行加密
     3. 保存用户信息
     4. 返回用户基本信息（不含密码）

2. 用户登录
   - 请求路径：POST /api/user/login
   - 请求参数：
     ```json
     {
       "username": "用户名",
       "password": "密码"
     }
     ```
   - 业务逻辑：
     1. 根据用户名查询用户
     2. 验证密码是否正确
     3. 生成登录令牌
     4. 返回用户信息和令牌

3. 修改密码
   - 请求路径：PUT /api/user/password
   - 请求参数：
     ```json
     {
       "userId": "用户ID",
       "oldPassword": "原密码",
       "newPassword": "新密码"
     }
     ```
   - 业务逻辑：
     1. 验证原密码是否正确
     2. 对新密码进行加密
     3. 更新密码

4. 更新用户信息
   - 请求路径：PUT /api/user/info
   - 请求参数：
     ```json
     {
       "userId": "用户ID",
       "email": "邮箱",
       "phone": "手机号",
       "avatar": "头像URL"
     }
     ```
   - 业务逻辑：
     1. 更新用户基本信息
     2. 返回更新后的用户信息

### 19.5 用户数据表结构
- user表：
  ```sql
  CREATE TABLE `user` (
    `id` bigint(20) NOT NULL AUTO_INCREMENT,
    `username` varchar(64) NOT NULL COMMENT '用户名',
    `password` varchar(64) NOT NULL COMMENT '密码',
    `email` varchar(128) DEFAULT NULL COMMENT '邮箱',
    `phone` varchar(20) DEFAULT NULL COMMENT '手机号',
    `avatar` varchar(255) DEFAULT NULL COMMENT '头像URL',
    `status` tinyint(4) NOT NULL DEFAULT '1' COMMENT '状态：0-禁用，1-启用',
    `create_time` datetime NOT NULL COMMENT '创建时间',
    `update_time` datetime NOT NULL COMMENT '更新时间',
    PRIMARY KEY (`id`),
    UNIQUE KEY `uk_username` (`username`),
    KEY `idx_email` (`email`),
    KEY `idx_phone` (`phone`)
  ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='用户表';
  ```

### 19.6 安全认证实现
1. 密码加密
   - 使用BCryptPasswordEncoder进行密码加密
   - 每次加密使用不同的盐值
   - 支持密码验证

2. JWT令牌认证
   - 用户登录成功后生成JWT令牌
   - 令牌包含用户ID和过期时间
   - 使用RSA非对称加密签名
   - 客户端请求时在Header中携带令牌

3. 权限控制
   - 基于Spring Security实现
   - 使用注解方式配置接口权限
   - 支持角色和权限两种方式
   - 自定义权限验证失败处理

## 20. 数据库表结构

### 20.1 用户相关表
- user表：
  ```sql
  CREATE TABLE `user` (
    `id` bigint(20) NOT NULL AUTO_INCREMENT,
    `username` varchar(64) NOT NULL COMMENT '用户名',
    `password` varchar(64) NOT NULL COMMENT '密码',
    `email` varchar(128) DEFAULT NULL COMMENT '邮箱',
    `phone` varchar(20) DEFAULT NULL COMMENT '手机号',
    `avatar` varchar(255) DEFAULT NULL COMMENT '头像URL',
    `status` tinyint(4) NOT NULL DEFAULT '1' COMMENT '状态：0-禁用，1-启用',
    `create_time` datetime NOT NULL COMMENT '创建时间',
    `update_time` datetime NOT NULL COMMENT '更新时间',
    PRIMARY KEY (`id`),
    UNIQUE KEY `uk_username` (`username`),
    KEY `idx_email` (`email`),
    KEY `idx_phone` (`phone`)
  ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='用户表';
  ```

### 20.2 商品相关表
- product表：
  ```sql
  CREATE TABLE `product` (
    `id` bigint(20) NOT NULL AUTO_INCREMENT,
    `name` varchar(128) NOT NULL COMMENT '商品名称',
    `category_id` bigint(20) NOT NULL COMMENT '分类ID',
    `price` decimal(10,2) NOT NULL COMMENT '价格',
    `stock` int(11) NOT NULL COMMENT '库存',
    `sales` int(11) NOT NULL DEFAULT '0' COMMENT '销量',
    `main_image` varchar(255) NOT NULL COMMENT '主图',
    `sub_images` text COMMENT '子图JSON数组',
    `description` text COMMENT '商品描述',
    `detail` text COMMENT '商品详情',
    `status` tinyint(4) NOT NULL DEFAULT '1' COMMENT '状态：0-下架，1-上架',
    `create_time` datetime NOT NULL COMMENT '创建时间',
    `update_time` datetime NOT NULL COMMENT '更新时间',
    PRIMARY KEY (`id`),
    KEY `idx_category_id` (`category_id`),
    KEY `idx_name` (`name`)
  ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='商品表';
  ```

### 20.3 订单相关表
- order表：
  ```sql
  CREATE TABLE `order` (
    `id` bigint(20) NOT NULL AUTO_INCREMENT,
    `order_no` varchar(64) NOT NULL COMMENT '订单编号',
    `user_id` bigint(20) NOT NULL COMMENT '用户ID',
    `total_amount` decimal(10,2) NOT NULL COMMENT '订单总金额',
    `status` tinyint(4) NOT NULL COMMENT '订单状态',
    `create_time` datetime NOT NULL COMMENT '创建时间',
    `pay_time` datetime DEFAULT NULL COMMENT '支付时间',
    `update_time` datetime NOT NULL COMMENT '更新时间',
    PRIMARY KEY (`id`),
    UNIQUE KEY `uk_order_no` (`order_no`),
    KEY `idx_user_id` (`user_id`)
  ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='订单表';
  ```

### 20.4 支付核心功能实现
- PaymentServiceImpl.java：
  ```java
  @Service
  @Slf4j
  public class PaymentServiceImpl implements PaymentService {
      @Autowired
      private PaymentMapper paymentMapper;
      
      @Autowired
      private OrderMapper orderMapper;
      
      @Autowired
      private OrderService orderService;
      
      @Autowired
      private AlipayServiceImpl alipayService;
      
      @Override
      @Transactional
      public String pay(PaymentRequest request) {
          // 1. 检查订单状态
          Order order = orderMapper.selectById(request.getOrderId());
          if (order == null) {
              throw new RuntimeException("订单不存在");
          }
          if (order.getStatus() != OrderStatus.UNPAID.getValue()) {
              throw new RuntimeException("订单状态不正确");
          }
          
          // 2. ���建支付记录
          Payment payment = new Payment();
          payment.setOrderId(order.getId());
          payment.setOrderNo(order.getOrderNo());
          payment.setUserId(order.getUserId());
          payment.setPaymentType(request.getPaymentType());
          payment.setPaymentNo(generatePaymentNo());
          payment.setAmount(order.getTotalAmount());
          payment.setPaymentStatus(PaymentStatus.PENDING);
          payment.setCreateTime(LocalDateTime.now());
          paymentMapper.insert(payment);
          
          // 3. 调用第三方支付接口
          return callThirdPartyPay(payment);
      }
      
      @Override
      @Transactional
      public void handleCallback(String paymentNo, String transactionId, BigDecimal amount) {
          // 1. 查询支付记录
          Payment payment = paymentMapper.selectByPaymentNo(paymentNo);
          if (payment == null) {
              throw new RuntimeException("支付记录不存在");
          }
          
          // 2. 验证支付金额
          if (payment.getAmount().compareTo(amount) != 0) {
              throw new RuntimeException("支付金额不匹配");
          }
          
          // 3. 更新支付状态
          payment.setStatus(PaymentStatus.SUCCESS.getValue());
          payment.setTransactionId(transactionId);
          payment.setPayTime(LocalDateTime.now());
          paymentMapper.updateById(payment);
          
          // 4. 更新订单状态
          orderService.paySuccess(payment.getOrderId().toString(), transactionId, amount);
      }
  }
  ```

### 20.5 支付宝支付实现
- AlipayServiceImpl.java：
  ```java
  @Service
  @Slf4j
  public class AlipayServiceImpl {
      public String createPayment(Payment payment, Order order) {
          try {
              AlipayTradePagePayResponse response = Factory.Payment.Page()
                  .pay(order.getOrderNo(), 
                       payment.getAmount().toString(), 
                       "商城订单-" + order.getOrderNo(),
                       "");
              return response.getBody();
          } catch (Exception e) {
              throw new RuntimeException("创建支付订单失败：" + e.getMessage());
          }
      }
  }
  ```

### 20.6 支付接口说明
1. 创建支付订单
   - 请求路径：POST /api/payment/create
   - 请求参数：
     ```json
     {
       "orderId": "订单ID",
       "paymentType": "支付方式：1-支付宝，2-微信支付，3-银行卡"
     }
     ```
   - 业务逻辑：
     1. 检查订单状态是否为待支付
     2. 创建支付记录
     3. 调用第三方支付接口
     4. 返回支付链接或二维码

2. 支付回调处理
   - 请求路径：POST /api/payment/callback/{type}
   - 请求参数：根据支付方式不同，参数不同
   - 业务逻辑：
     1. 验证支付回调参数
     2. 查询支付记录
     3. 验证支付金额
     4. 更新支付状态
     5. 更新订单状态

3. 查询支付状态
   - 请求路径：GET /api/payment/status/{paymentNo}
   - 请求参数：支付流水号
   - 业务逻辑：
     1. 查询支付记录
     2. 返回支付状态信息

### 20.7 支付数据表结构
1. payment表：
   ```sql
   CREATE TABLE `payment` (
     `id` bigint(20) NOT NULL AUTO_INCREMENT,
     `payment_no` varchar(64) NOT NULL COMMENT '支付流水号',
     `order_id` bigint(20) NOT NULL COMMENT '订单ID',
     `order_no` varchar(64) NOT NULL COMMENT '订单编号',
     `user_id` bigint(20) NOT NULL COMMENT '用户ID',
     `payment_type` tinyint(4) NOT NULL COMMENT '支付方式：1-支付宝，2-微信支付，3-银行卡',
     `transaction_id` varchar(64) DEFAULT NULL COMMENT '第三方交易号',
     `amount` decimal(10,2) NOT NULL COMMENT '支付金额',
     `status` tinyint(4) NOT NULL COMMENT '支付状态：0-待支付，1-支付成功，2-支付失败',
     `pay_time` datetime DEFAULT NULL COMMENT '支付时间',
     `create_time` datetime NOT NULL COMMENT '创建时间',
     `update_time` datetime NOT NULL COMMENT '更新时间',
     PRIMARY KEY (`id`),
     UNIQUE KEY `uk_payment_no` (`payment_no`),
     KEY `idx_order_id` (`order_id`),
     KEY `idx_user_id` (`user_id`)
   ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='支付表';
   ```

2. payment_log表：
   ```sql
   CREATE TABLE `payment_log` (
     `id` bigint(20) NOT NULL AUTO_INCREMENT,
     `payment_no` varchar(64) NOT NULL COMMENT '支付流水号',
     `log_type` tinyint(4) NOT NULL COMMENT '日志类型：1-创建，2-成功，3-失败',
     `content` text COMMENT '日志内容',
     `create_time` datetime NOT NULL COMMENT '创建时间',
     PRIMARY KEY (`id`),
     KEY `idx_payment_no` (`payment_no`)
   ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='支付日志表';
   ```

### 20.8 支付安全实现
1. 签名验证
   - 使用RSA非对称加密算法
   - 验证支付回调请求的签名
   - 防止回调请求被篡改

2. 金额验证
   - 验证支付金额与订单金额是否一致
   - 防止金额被篡改

3. 幂等性处理
   - 使用支付流水号作为唯一标识
   - 防止重复回调处理

4. 超时处理
   - 设置支付超时时间（30分钟）
   - 超时自动关闭支付订单
   - 定时任务清理超时订单

## 21. 订单模块实现

### 21.1 订单相关文件
- 实体类：
  - Order.java：订单实体类
  - OrderItem.java：订单项实体类
- 数据访问层：
  - OrderMapper.java：订单数据访问接口
  - OrderItemMapper.java：订��项数据访问接口
- 服务层：
  - OrderService.java：订单服务接口
  - OrderServiceImpl.java：订单服务实现类
- 控制层：
  - OrderController.java：订单控制器

### 21.2 订单创建流程
- OrderController.java：
  ```java
  @PostMapping("/create")
  public Result<OrderDTO> create(@RequestBody @Valid OrderCreateRequest request) {
      try {
          OrderDTO order = orderService.create(request.getUserId(), request.getCartIds());
          return Result.success(order);
      } catch (Exception e) {
          return Result.error(e.getMessage());
      }
  }
  ```

- OrderServiceImpl.java：
  ```java
  @Transactional
  public OrderDTO create(Long userId, List<Long> cartIds) {
      // 1. 获取购物车商品
      List<Cart> cartList = getCartList(userId, cartIds);
      
      // 2. 检查商品库存
      checkStock(cartList);
      
      // 3. 计算订单总金额
      BigDecimal totalAmount = calculateTotalAmount(cartList);
      
      // 4. 创建订单
      Order order = createOrder(userId, totalAmount);
      
      // 5. 创建订单项
      List<OrderItem> orderItems = createOrderItems(order.getId(), cartList);
      
      // 6. 更新商品库存和销量
      updateProductStock(cartList);
      
      // 7. 清空购物车
      clearCart(userId, cartIds);
      
      return convertToDTO(order, orderItems);
  }
  ```

### 21.3 订单核心功能实现
- OrderServiceImpl.java：
  ```java
  @Service
  @Slf4j
  public class OrderServiceImpl implements OrderService {
      @Autowired
      private OrderMapper orderMapper;
      
      @Autowired
      private OrderItemMapper orderItemMapper;
      
      @Autowired
      private CartMapper cartMapper;
      
      @Autowired
      private ProductMapper productMapper;
      
      @Override
      @Transactional
      public OrderDTO create(Long userId, List<Long> cartIds) {
          // 1. 获取购物车商品
          List<Cart> cartList = getCartList(userId, cartIds);
          if (cartList.isEmpty()) {
              throw new RuntimeException("购物车为空");
          }
          
          // 2. 检查商品库存
          checkStock(cartList);
          
          // 3. 计算订单总金额
          BigDecimal totalAmount = calculateTotalAmount(cartList);
          
          // 4. 创建订单
          Order order = createOrder(userId, totalAmount);
          
          // 5. 创建订单项
          List<OrderItem> orderItems = createOrderItems(order.getId(), cartList);
          
          // 6. 更新商品库存和销量
          updateProductStock(cartList);
          
          // 7. 清空购物车
          clearCart(userId, cartIds);
          
          return convertToDTO(order, orderItems);
      }
      
      @Override
      @Transactional
      public void pay(Long orderId) {
          Order order = orderMapper.selectById(orderId);
          if (order == null) {
              throw new RuntimeException("订单不存在");
          }
          
          if (order.getStatus() != OrderStatus.UNPAID.getValue()) {
              throw new RuntimeException("订单状态不正确");
          }
          
          order.setStatus(OrderStatus.PAID.getValue());
          order.setPayTime(new Date());
          orderMapper.updateById(order);
      }
      
      @Override
      @Transactional
      public void cancel(Long orderId) {
          Order order = orderMapper.selectById(orderId);
          if (order == null) {
              throw new RuntimeException("订单不存在");
          }
          
          // 只有待付款和待发货状态的订单才能取消
          if (order.getStatus() != 0 && order.getStatus() != 1) {
              throw new RuntimeException("订单状态不正确");
          }
          
          order.setStatus(OrderStatus.CANCELLED.getValue());
          orderMapper.updateById(order);
          
          // 恢复商品库存
          List<OrderItem> items = orderItemMapper.selectByOrderId(orderId);
          for (OrderItem item : items) {
              Product product = productMapper.selectById(item.getProductId());
              if (product != null) {
                  product.setStock(product.getStock() + item.getQuantity());
                  productMapper.updateById(product);
              }
          }
      }
  }
  ```

### 21.4 订单接口说明
1. 创建订单
   - 请求路径：POST /api/order/create
   - 请求参数：
     ```json
     {
       "userId": "用户ID",
       "cartIds": ["购物车ID列表"]
     }
     ```
   - 业务逻辑：
     1. 获取购物车商品列表
     2. 检查商品库存
     3. 计算订单总金额
     4. 创建订单记录
     5. 创建订单项记录
     6. 更新商品库存
     7. 清空购物车
     8. 返回订单信息

2. 订单列表查询
   - 请求路径：GET /api/order/list
   - 请求参数：
     ```json
     {
       "userId": "用户ID",
       "status": "订单状态",
       "pageNum": "页码",
       "pageSize": "每页数量"
     }
     ```
   - 业务逻辑：
     1. 根据用户ID和状态查询订单
     2. 关联查询订单项信息
     3. 返回分页数据

3. 订单详情查询
   - 请求路径：GET /api/order/detail/{id}
   - 请求参数：订单ID
   - 业务逻辑：
     1. 查询订单基本信息
     2. 查询订单项列表
     3. 返回订单详情

4. 订单支付
   - 请求路径：PUT /api/order/{id}/pay
   - 请求参数：订单ID
   - 业务逻辑：
     1. 检查订单状态
     2. 更新订单状态为已支付
     3. 记录支付时间

5. 订单取消
   - 请求路径：PUT /api/order/{id}/cancel
   - 请求参数：订单ID
   - 业务逻辑：
     1. 检查订单状态
     2. 更新订单状态为已取消
     3. 恢复商品库存

6. 确认收货
   - 请求路径：PUT /api/order/{id}/confirm
   - 请求参数：订单ID
   - 业务逻辑：
     1. 检查订单状态
     2. 更新订单状态为已完成
     3. 更新商品销量

### 21.5 订单数据表结构
1. order表：
   ```sql
   CREATE TABLE `order` (
     `id` bigint(20) NOT NULL AUTO_INCREMENT,
     `order_no` varchar(64) NOT NULL COMMENT '订单编号',
     `user_id` bigint(20) NOT NULL COMMENT '用户ID',
     `total_amount` decimal(10,2) NOT NULL COMMENT '订单总金额',
     `status` tinyint(4) NOT NULL COMMENT '订单状态：0-待付款，1-待发货，2-待收货，3-已完成，4-已取消',
     `pay_time` datetime DEFAULT NULL COMMENT '支付时间',
     `deliver_time` datetime DEFAULT NULL COMMENT '发货时间',
     `finish_time` datetime DEFAULT NULL COMMENT '完成时间',
     `create_time` datetime NOT NULL COMMENT '创建时间',
     `update_time` datetime NOT NULL COMMENT '更新时间',
     PRIMARY KEY (`id`),
     UNIQUE KEY `uk_order_no` (`order_no`),
     KEY `idx_user_id` (`user_id`),
     KEY `idx_status` (`status`)
   ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='订单表';
   ```

2. order_item表：
   ```sql
   CREATE TABLE `order_item` (
     `id` bigint(20) NOT NULL AUTO_INCREMENT,
     `order_id` bigint(20) NOT NULL COMMENT '订单ID',
     `product_id` bigint(20) NOT NULL COMMENT '商品ID',
     `product_name` varchar(128) NOT NULL COMMENT '商品名称',
     `product_image` varchar(255) NOT NULL COMMENT '商品图片',
     `quantity` int(11) NOT NULL COMMENT '购买数量',
     `price` decimal(10,2) NOT NULL COMMENT '商品单价',
     `total_price` decimal(10,2) NOT NULL COMMENT '商品总价',
     `create_time` datetime NOT NULL COMMENT '创建时间',
     PRIMARY KEY (`id`),
     KEY `idx_order_id` (`order_id`),
     KEY `idx_product_id` (`product_id`)
   ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='订单项表';
   ```

### 21.6 订单状态流转
1. 状态定义
   - UNPAID(0)：待付款
   - PAID(1)：待发货
   - DELIVERED(2)：待收货
   - COMPLETED(3)：已完成
   - CANCELLED(4)：已取消

2. 状态流转规则
   - 创建订单：初始状态为待付款(0)
   - 支付成功：待付款(0) -> 待发货(1)
   - 发货：待发货(1) -> 待收货(2)
   - 确认收货：待收货(2) -> 已完成(3)
   - 取消订单：待付款(0)/待发货(1) -> 已取消(4)
   - 超时未支付：待付款(0) -> 已取消(4)

3. 状态校验
   - 每个操作前都要校验当前状态
   - 只有特定状态才能执行相应操作
   - 状态变更要保证原子性

## 22. 分类模块实现

### 22.1 分类相关文件
- 实体类：
  - Category.java：分类实体类
- 数据访问层：
  - CategoryMapper.java：分类数据访问接口
- 服务层：
  - CategoryService.java：分类服务接口
  - CategoryServiceImpl.java：分类服务实现类
- 控制层：
  - CategoryController.java：分类控制器

### 22.2 分类核心功能实现
- CategoryServiceImpl.java：
  ```java
  @Service
  public class CategoryServiceImpl implements CategoryService {
      @Autowired
      private CategoryMapper categoryMapper;
      
      @Override
      public List<Category> list() {
          return categoryMapper.selectList(new QueryWrapper<Category>()
                  .orderByAsc("sort"));
      }
      
      @Override
      public List<Category> listTree() {
          // 1. 获取所有分类
          List<Category> allCategories = list();
          
          // 2. 按父ID分组
          Map<Long, List<Category>> parentMap = allCategories.stream()
                  .collect(Collectors.groupingBy(category -> 
                      category.getParentId() == null ? 0L : category.getParentId()));
          
          // 3. 构建树形结构
          return buildTree(parentMap, 0L);
      }
      
      private List<Category> buildTree(Map<Long, List<Category>> parentMap, Long parentId) {
          List<Category> children = parentMap.get(parentId);
          if (children == null) {
              return new ArrayList<>();
          }
          
          for (Category child : children) {
              List<Category> grandChildren = buildTree(parentMap, child.getId());
              if (!grandChildren.isEmpty()) {
                  child.setChildren(grandChildren);
              }
          }
          
          return children;
      }
  }
  ```

### 22.3 分类接口说明
1. 获取分类列表
   - 请求路径：GET /api/category/list
   - 请求参数：无
   - 业务逻辑：
     1. 查询所有分类
     2. 按排序字段升序排序
     3. 返回分类列表

2. 获取分类树
   - 请求路径：GET /api/category/tree
   - 请求参数：无
   - 业务逻辑：
     1. 查询所有分类
     2. 构建父子层级关系
     3. 返回树形结构数据

### 22.4 分类数据表结构
- category表：
  ```sql
  CREATE TABLE `category` (
    `id` bigint(20) NOT NULL AUTO_INCREMENT,
    `parent_id` bigint(20) DEFAULT NULL COMMENT '父分类ID',
    `name` varchar(64) NOT NULL COMMENT '分类名称',
    `icon` varchar(255) DEFAULT NULL COMMENT '分类图标',
    `sort` int(11) NOT NULL DEFAULT '0' COMMENT '排序',
    `status` tinyint(4) NOT NULL DEFAULT '1' COMMENT '状态：0-禁用，1-启用',
    `create_time` datetime NOT NULL COMMENT '创建时间',
    `update_time` datetime NOT NULL COMMENT '更新时间',
    PRIMARY KEY (`id`),
    KEY `idx_parent_id` (`parent_id`),
    KEY `idx_sort` (`sort`)
  ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='商品分类表';
  ```

### 22.5 分类树形结构
1. 数据结构
   ```java
   public class Category {
       private Long id;
       private Long parentId;
       private String name;
       private String icon;
       private Integer sort;
       private Integer status;
       private List<Category> children;
   }
   ```

2. 树形结构特点
   - 支持无限层级
   - 父子关系通过parentId关联
   - 同级分类通过sort字段排序
   - children字段存储子分类列表

3. 构建树形结构步骤
   1. 查询所有分类记录
   2. 将分类按parentId分组
   3. 从根节点(parentId=0)开始递归构建
   4. 设置每个节点的子节点列表

### 22.6 分类缓存设计
1. 缓存策略
   - 使用Redis缓存分类数据
   - 按列表和树形两种结构分别缓存
   - 设置合适的过期时间

2. 缓存更新
   - 添加/修改/删除分类时更新缓存
   - 使用分布式锁保证并发安全
   - 采用双写一致性方案

3. 缓存键设计
   ```java
   private static final String CATEGORY_LIST_KEY = "category:list";
   private static final String CATEGORY_TREE_KEY = "category:tree";
   private static final int CACHE_EXPIRE_HOURS = 24;
   ```

4. 缓存实现
   ```java
   @Cacheable(value = "category", key = "'tree'")
   public List<Category> listTree() {
       // 1. 尝试从缓存获取
       String cacheKey = CATEGORY_TREE_KEY;
       List<Category> categoryTree = redisTemplate.opsForValue().get(cacheKey);
       if (categoryTree != null) {
           return categoryTree;
       }
       
       // 2. 缓存未命中，构建树形结构
       categoryTree = buildCategoryTree();
       
       // 3. 放入缓存
       redisTemplate.opsForValue().set(cacheKey, categoryTree, 
           CACHE_EXPIRE_HOURS, TimeUnit.HOURS);
       
       return categoryTree;
   }
   ```

## 23. 搜索模块实现

### 23.1 搜索功能实现
1. 基于MySQL的搜索实现
   - ProductMapper.xml：
     ```xml
     <select id="searchProducts" resultType="com.mall.entity.Product">
         SELECT p.*, c.name as category_name
         FROM product p
         LEFT JOIN category c ON p.category_id = c.id
         WHERE p.status = 1
         <if test="categoryId != null">
             AND p.category_id = #{categoryId}
         </if>
         <if test="keyword != null and keyword != ''">
             AND (
                 p.name LIKE CONCAT('%', #{keyword}, '%')
                 OR p.description LIKE CONCAT('%', #{keyword}, '%')
                 OR c.name LIKE CONCAT('%', #{keyword}, '%')
             )
         </if>
         <choose>
             <when test="orderBy == 'price_asc'">
                 ORDER BY p.price ASC
             </when>
             <when test="orderBy == 'price_desc'">
                 ORDER BY p.price DESC
             </when>
             <when test="orderBy == 'sales_desc'">
                 ORDER BY p.sales DESC
             </when>
             <otherwise>
                 ORDER BY p.create_time DESC
             </otherwise>
         </choose>
     </select>
     ```

2. 搜索功能特点
   - 支持多字段模糊搜索
     - 商品名称
     - 商品描述
     - 分类名称
   - 支持分类筛选
   - 支持多种排序方式
     - 价格升序/降序
     - 销量降序
     - 最新上架

### 23.2 搜索性能优化
1. 数据库索引优化
   ```sql
   -- 商品表索引
   ALTER TABLE product ADD INDEX idx_name (name);
   ALTER TABLE product ADD INDEX idx_category_status (category_id, status);
   ALTER TABLE product ADD INDEX idx_price (price);
   ALTER TABLE product ADD INDEX idx_sales (sales);
   ALTER TABLE product ADD INDEX idx_create_time (create_time);
   
   -- 分类表索引
   ALTER TABLE category ADD INDEX idx_name (name);
   ```

2. SQL优化
   - 使用左连接避免笛卡尔积
   - 使用索引字段作为查询条件
   - 合理使用索引排序
   - 避免使用select *

3. 查询缓存
   ```java
   @Cacheable(value = "product", key = "'search:' + #categoryId + ':' + #keyword + ':' + #orderBy")
   public Page<ProductDTO> search(Long categoryId, String keyword, String orderBy) {
       // 1. 尝试从缓存获取
       String cacheKey = String.format("product:search:%s:%s:%s", 
           categoryId, keyword, orderBy);
       Page<ProductDTO> result = redisTemplate.opsForValue().get(cacheKey);
       if (result != null) {
           return result;
       }
       
       // 2. 缓存未命中，执行查询
       result = doSearch(categoryId, keyword, orderBy);
       
       // 3. 放入缓存
       redisTemplate.opsForValue().set(cacheKey, result, 1, TimeUnit.HOURS);
       
       return result;
   }
   ```

### 23.3 搜索接口说明
1. 商品搜索
   - 请求路径：GET /api/product/search
   - 请求参数：
     ```json
     {
       "categoryId": "分类ID",
       "keyword": "搜索关键词",
       "orderBy": "排序方式",
       "pageNum": "页码",
       "pageSize": "每页数量"
     }
     ```
   - 业务逻辑：
     1. 参数校验
     2. 构建查询条件
     3. 执行分页查询
     4. 转换查询结果
     5. 返回分页数据

2. 搜索建议
   - 请求路径：GET /api/product/suggest
   - 请求参数：keyword（搜索关键词）
   - 业务逻辑：
     1. 从搜索历史中获取相关建议
     2. 从热门搜索中获取建议
     3. 返回建议列表

### 23.4 搜索历史记录
1. 数据表结构
   ```sql
   CREATE TABLE `search_history` (
     `id` bigint(20) NOT NULL AUTO_INCREMENT,
     `user_id` bigint(20) NOT NULL COMMENT '用户ID',
     `keyword` varchar(128) NOT NULL COMMENT '搜索关键词',
     `create_time` datetime NOT NULL COMMENT '搜索时间',
     PRIMARY KEY (`id`),
     KEY `idx_user_keyword` (`user_id`, `keyword`),
     KEY `idx_create_time` (`create_time`)
   ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='搜索历史表';
   ```

2. 历史记录管理
   - 记录用户搜索关键词
   - 按时间倒序排列
   - 限制每个用户的记录数量
   - 支持删除历史记录

### 23.5 热门搜索
1. 数据表结构
   ```sql
   CREATE TABLE `hot_search` (
     `id` bigint(20) NOT NULL AUTO_INCREMENT,
     `keyword` varchar(128) NOT NULL COMMENT '搜索关键词',
     `count` int(11) NOT NULL DEFAULT '0' COMMENT '搜索次数',
     `create_time` datetime NOT NULL COMMENT '创建时间',
     `update_time` datetime NOT NULL COMMENT '更新时间',
     PRIMARY KEY (`id`),
     UNIQUE KEY `uk_keyword` (`keyword`),
     KEY `idx_count` (`count`)
   ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='热门搜索表';
   ```

2. 热门搜索统计
   - 实时统计搜索次数
   - 定时更新热门关键词
   - 使用Redis缓存热门关键词
   - 支持手动设置热门关键词

### 23.6 搜索性能监控
1. 监控指标
   - 搜索响应时间
   - 搜索QPS
   - 缓存命中率
   - 错误率统计

2. 监控实现
   ```java
   @Aspect
   @Component
   public class SearchMonitor {
       private Counter searchCounter;
       private Timer searchTimer;
       private Counter errorCounter;
       
       @Around("execution(* com.mall.service.impl.SearchServiceImpl.search(..))")
       public Object monitorSearch(ProceedingJoinPoint joinPoint) {
           Timer.Sample sample = Timer.start();
           try {
               searchCounter.increment();
               Object result = joinPoint.proceed();
               searchTimer.record(sample.stop());
               return result;
           } catch (Throwable e) {
               errorCounter.increment();
               throw new RuntimeException(e);
           }
       }
   }
   ```

## 24. 系统配置和通用功能实现

### 24.1 通用返回结果
- Result.java：
  ```java
  @Data
  public class Result<T> {
      private Integer code;
      private String message;
      private T data;
      
      private Result(Integer code, String message, T data) {
          this.code = code;
          this.message = message;
          this.data = data;
      }
      
      public static <T> Result<T> success(T data) {
          return new Result<>(200, "success", data);
      }
      
      public static <T> Result<T> success() {
          return new Result<>(200, "success", null);
      }
      
      public static <T> Result<T> error(String message) {
          return new Result<>(500, message, null);
      }
      
      public static <T> Result<T> error(Integer code, String message) {
          return new Result<>(code, message, null);
      }
  }
  ```

### 24.2 跨域配置
- CorsConfig.java：
  ```java
  @Configuration
  public class CorsConfig implements WebMvcConfigurer {
      @Override
      public void addCorsMappings(CorsRegistry registry) {
          registry.addMapping("/**")
                  .allowedOrigins("http://localhost:8081")
                  .allowedMethods("GET", "POST", "PUT", "DELETE", "OPTIONS")
                  .allowedHeaders("*")
                  .allowCredentials(true)
                  .maxAge(3600);
      }
  }
  ```

### 24.3 支付配置
1. 支付宝配置
   ```java
   @Configuration
   @ConfigurationProperties(prefix = "alipay")
   @Data
   public class AlipayConfig {
       private String appId;
       private String privateKey;
       private String publicKey;
       private String notifyUrl;
       private String returnUrl;
       private String gatewayUrl;
       
       @PostConstruct
       public void init() {
           // 初始化支付宝SDK
           Factory.setOptions(getOptions());
       }
       
       private Config getOptions() {
           Config config = new Config();
           config.protocol = "https";
           config.gatewayHost = "openapi.alipay.com";
           config.signType = "RSA2";
           config.appId = this.appId;
           config.merchantPrivateKey = this.privateKey;
           config.alipayPublicKey = this.publicKey;
           config.notifyUrl = this.notifyUrl;
           return config;
       }
   }
   ```

2. 微信支付配置
   ```java
   @Configuration
   @ConfigurationProperties(prefix = "wxpay")
   @Data
   public class WechatPayConfig {
       private String appId;
       private String mchId;
       private String key;
       private String notifyUrl;
       private String signType;
       private String tradeType;
       
       @Bean
       public WXPay wxPay() {
           try {
               return new WXPay(new WXPayConfig() {
                   @Override
                   public String getAppID() {
                       return appId;
                   }
                   
                   @Override
                   public String getMchID() {
                       return mchId;
                   }
                   
                   @Override
                   public String getKey() {
                       return key;
                   }
               });
           } catch (Exception e) {
               throw new RuntimeException("初始化微信支付失败", e);
           }
       }
   }
   ```

### 24.4 定时任务配置
```java
@Configuration
@EnableScheduling
public class ScheduleConfig {
    @Bean
    public TaskScheduler taskScheduler() {
        ThreadPoolTaskScheduler scheduler = new ThreadPoolTaskScheduler();
        scheduler.setPoolSize(10);
        scheduler.setThreadNamePrefix("task-");
        return scheduler;
    }
}
```

### 24.5 异常处理
1. 全局异常处理器
   ```java
   @RestControllerAdvice
   @Slf4j
   public class GlobalExceptionHandler {
       @ExceptionHandler(Exception.class)
       public Result<Void> handleException(Exception e) {
           log.error("系统异常", e);
           return Result.error("系统异常，请稍后重试");
       }
       
       @ExceptionHandler(BusinessException.class)
       public Result<Void> handleBusinessException(BusinessException e) {
           log.warn("业务异常：{}", e.getMessage());
           return Result.error(e.getMessage());
       }
       
       @ExceptionHandler(ValidationException.class)
       public Result<Void> handleValidationException(ValidationException e) {
           log.warn("参数校验异常：{}", e.getMessage());
           return Result.error("参数错误：" + e.getMessage());
       }
   }
   ```

2. 自定义业务异常
   ```java
   @Data
   public class BusinessException extends RuntimeException {
       private Integer code;
       
       public BusinessException(String message) {
           super(message);
           this.code = 500;
       }
       
       public BusinessException(Integer code, String message) {
           super(message);
           this.code = code;
       }
   }
   ```

### 24.6 接口文档配置
```java
@Configuration
@EnableSwagger2
public class SwaggerConfig {
    @Bean
    public Docket createRestApi() {
        return new Docket(DocumentationType.SWAGGER_2)
                .apiInfo(apiInfo())
                .select()
                .apis(RequestHandlerSelectors.basePackage("com.mall.controller"))
                .paths(PathSelectors.any())
                .build();
    }
    
    private ApiInfo apiInfo() {
        return new ApiInfoBuilder()
                .title("商城API文档")
                .description("商城系统接口文档")
                .version("1.0")
                .build();
    }
}
```

### 24.7 系统常量定义
```java
public class Constants {
    // 用户相关
    public static final String TOKEN_HEADER = "Authorization";
    public static final String TOKEN_PREFIX = "Bearer ";
    public static final long TOKEN_EXPIRE_TIME = 24 * 60 * 60 * 1000; // 24小时
    
    // 订单相关
    public static final int ORDER_TIMEOUT_MINUTES = 30; // 订单超时时间
    public static final String ORDER_PREFIX = "ORDER"; // 订单号前缀
    
    // 支付相关
    public static final String ALIPAY_CALLBACK_SUCCESS = "success";
    public static final String ALIPAY_TRADE_SUCCESS = "TRADE_SUCCESS";
    
    // 缓存相关
    public static final String CATEGORY_CACHE_KEY = "category:list";
    public static final String PRODUCT_CACHE_KEY = "product:detail:";
    public static final int CACHE_EXPIRE_HOURS = 24;
}
```

### 24.8 系���配置文件
```yaml
server:
  port: 8080
  servlet:
    context-path: /api

spring:
  datasource:
    url: jdbc:mysql://localhost:3306/mall?useUnicode=true&characterEncoding=utf-8
    username: root
    password: root
    driver-class-name: com.mysql.cj.jdbc.Driver
  
  redis:
    host: localhost
    port: 6379
    password: 
    database: 0
    
  jackson:
    date-format: yyyy-MM-dd HH:mm:ss
    time-zone: GMT+8
    
mybatis-plus:
  mapper-locations: classpath:mapper/*.xml
  type-aliases-package: com.mall.entity
  configuration:
    map-underscore-to-camel-case: true
    log-impl: org.apache.ibatis.logging.stdout.StdOutImpl
    
alipay:
  app-id: your-app-id
  private-key: your-private-key
  public-key: alipay-public-key
  notify-url: http://your-domain/api/pay/alipay/notify
  return-url: http://your-domain/pay/success
  
wxpay:
  app-id: your-app-id
  mch-id: your-mch-id
  key: your-key
  notify-url: http://your-domain/api/pay/wxpay/notify
```

## 25. 安全认证和工具类实现

### 25.1 JWT认证实现
```java
@Component
public class JwtTokenProvider {
    @Value("${jwt.secret}")
    private String jwtSecret;
    
    @Value("${jwt.expire}")
    private long jwtExpiration;
    
    public String generateToken(UserDetails userDetails) {
        Map<String, Object> claims = new HashMap<>();
        return createToken(claims, userDetails.getUsername());
    }
    
    public String getUsernameFromToken(String token) {
        Claims claims = Jwts.parser()
                .setSigningKey(jwtSecret)
                .parseClaimsJws(token)
                .getBody();
        
        return claims.get("username", String.class);
    }
    
    public boolean validateToken(String token) {
        try {
            Jwts.parser().setSigningKey(jwtSecret).parseClaimsJws(token);
            return true;
        } catch (Exception e) {
            return false;
        }
    }
}
```

### 25.2 认证过滤器
```java
@Component
public class JwtAuthenticationFilter extends OncePerRequestFilter {
    @Autowired
    private JwtTokenProvider tokenProvider;
    
    @Autowired
    private UserDetailsService userDetailsService;
    
    @Override
    protected void doFilterInternal(HttpServletRequest request, 
                                  HttpServletResponse response, 
                                  FilterChain filterChain) 
            throws ServletException, IOException {
        try {
            String token = getTokenFromRequest(request);
            if (StringUtils.hasText(token) && tokenProvider.validateToken(token)) {
                String username = tokenProvider.getUsernameFromToken(token);
                UserDetails userDetails = userDetailsService.loadUserByUsername(username);
                
                UsernamePasswordAuthenticationToken authentication = 
                    new UsernamePasswordAuthenticationToken(
                        userDetails, null, userDetails.getAuthorities());
                authentication.setDetails(new WebAuthenticationDetailsSource()
                    .buildDetails(request));
                
                SecurityContextHolder.getContext().setAuthentication(authentication);
            }
        } catch (Exception e) {
            logger.error("认证异常", e);
        }
        
        filterChain.doFilter(request, response);
    }
    
    private String getTokenFromRequest(HttpServletRequest request) {
        String bearerToken = request.getHeader("Authorization");
        if (StringUtils.hasText(bearerToken) && bearerToken.startsWith("Bearer ")) {
            return bearerToken.substring(7);
        }
        return null;
    }
}
```

### 25.3 安全配置
```java
@Configuration
@EnableWebSecurity
@EnableGlobalMethodSecurity(prePostEnabled = true)
public class SecurityConfig extends WebSecurityConfigurerAdapter {
    @Autowired
    private JwtAuthenticationFilter jwtAuthenticationFilter;
    
    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http.csrf().disable()
            .sessionManagement()
            .sessionCreationPolicy(SessionCreationPolicy.STATELESS)
            .and()
            .authorizeRequests()
            .antMatchers("/api/auth/**").permitAll()
            .antMatchers("/api/public/**").permitAll()
            .anyRequest().authenticated();
        
        http.addFilterBefore(jwtAuthenticationFilter, 
            UsernamePasswordAuthenticationFilter.class);
    }
    
    @Override
    public void configure(WebSecurity web) {
        web.ignoring().antMatchers(
            "/swagger-ui.html",
            "/swagger-resources/**",
            "/webjars/**",
            "/v2/api-docs"
        );
    }
}
```

### 25.4 RSA工具类
```java
public class RSAUtil {
    private static final Logger log = LoggerFactory.getLogger(RSAUtil.class);
    
    public static PrivateKey loadPrivateKey(String privateKeyPEM) {
        try {
            log.debug("开始加载私钥...");
            ByteArrayInputStream inputStream = new ByteArrayInputStream(
                privateKeyPEM.getBytes(StandardCharsets.UTF_8));
            PrivateKey privateKey = PemUtil.loadPrivateKey(inputStream);
            log.debug("私钥加载成功: {}", privateKey.getAlgorithm());
            return privateKey;
        } catch (Exception e) {
            log.error("加载私钥失败: {}", e.getMessage(), e);
            throw new RuntimeException("加载私钥失败: " + e.getMessage(), e);
        }
    }
    
    public static String encrypt(String content, PublicKey publicKey) {
        try {
            Cipher cipher = Cipher.getInstance("RSA");
            cipher.init(Cipher.ENCRYPT_MODE, publicKey);
            byte[] bytes = cipher.doFinal(content.getBytes());
            return Base64.getEncoder().encodeToString(bytes);
        } catch (Exception e) {
            throw new RuntimeException("RSA加密失败", e);
        }
    }
    
    public static String decrypt(String content, PrivateKey privateKey) {
        try {
            Cipher cipher = Cipher.getInstance("RSA");
            cipher.init(Cipher.DECRYPT_MODE, privateKey);
            byte[] bytes = cipher.doFinal(Base64.getDecoder().decode(content));
            return new String(bytes);
        } catch (Exception e) {
            throw new RuntimeException("RSA解密失败", e);
        }
    }
}
```

### 25.5 加密工具类
```java
public class EncryptUtil {
    private static final String AES_KEY = "AES_KEY";
    private static final String AES_ALGORITHM = "AES/CBC/PKCS5Padding";
    
    public static String aesEncrypt(String content, String password) {
        try {
            KeyGenerator keyGen = KeyGenerator.getInstance("AES");
            SecureRandom random = SecureRandom.getInstance("SHA1PRNG");
            random.setSeed(password.getBytes());
            keyGen.init(128, random);
            SecretKey key = keyGen.generateKey();
            
            Cipher cipher = Cipher.getInstance(AES_ALGORITHM);
            cipher.init(Cipher.ENCRYPT_MODE, key);
            byte[] bytes = cipher.doFinal(content.getBytes());
            return Base64.getEncoder().encodeToString(bytes);
        } catch (Exception e) {
            throw new RuntimeException("AES加密失败", e);
        }
    }
    
    public static String aesDecrypt(String content, String password) {
        try {
            KeyGenerator keyGen = KeyGenerator.getInstance("AES");
            SecureRandom random = SecureRandom.getInstance("SHA1PRNG");
            random.setSeed(password.getBytes());
            keyGen.init(128, random);
            SecretKey key = keyGen.generateKey();
            
            Cipher cipher = Cipher.getInstance(AES_ALGORITHM);
            cipher.init(Cipher.DECRYPT_MODE, key);
            byte[] bytes = cipher.doFinal(Base64.getDecoder().decode(content));
            return new String(bytes);
        } catch (Exception e) {
            throw new RuntimeException("AES解密失败", e);
        }
    }
    
    public static String md5(String content) {
        try {
            MessageDigest md = MessageDigest.getInstance("MD5");
            byte[] bytes = md.digest(content.getBytes());
            return bytesToHex(bytes);
        } catch (Exception e) {
            throw new RuntimeException("MD5加密失败", e);
        }
    }
    
    private static String bytesToHex(byte[] bytes) {
        StringBuilder sb = new StringBuilder();
        for (byte b : bytes) {
            String hex = Integer.toHexString(b & 0xFF);
            if (hex.length() == 1) {
                sb.append('0');
            }
            sb.append(hex);
        }
        return sb.toString();
    }
}
```

### 25.6 日期工具类
```java
public class DateUtil {
    private static final String DEFAULT_FORMAT = "yyyy-MM-dd HH:mm:ss";
    
    public static String format(Date date) {
        return format(date, DEFAULT_FORMAT);
    }
    
    public static String format(Date date, String pattern) {
        if (date == null) {
            return null;
        }
        SimpleDateFormat sdf = new SimpleDateFormat(pattern);
        return sdf.format(date);
    }
    
    public static Date parse(String dateStr) {
        return parse(dateStr, DEFAULT_FORMAT);
    }
    
    public static Date parse(String dateStr, String pattern) {
        if (StringUtils.isEmpty(dateStr)) {
            return null;
        }
        try {
            SimpleDateFormat sdf = new SimpleDateFormat(pattern);
            return sdf.parse(dateStr);
        } catch (Exception e) {
            throw new RuntimeException("日期解析失败", e);
        }
    }
    
    public static Date addDays(Date date, int days) {
        Calendar cal = Calendar.getInstance();
        cal.setTime(date);
        cal.add(Calendar.DAY_OF_MONTH, days);
        return cal.getTime();
    }
    
    public static boolean isSameDay(Date date1, Date date2) {
        Calendar cal1 = Calendar.getInstance();
        cal1.setTime(date1);
        Calendar cal2 = Calendar.getInstance();
        cal2.setTime(date2);
        return cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) &&
               cal1.get(Calendar.MONTH) == cal2.get(Calendar.MONTH) &&
               cal1.get(Calendar.DAY_OF_MONTH) == cal2.get(Calendar.DAY_OF_MONTH);
    }
}
```

## 26. 缓存和性能优化实现

### 26.1 Redis缓存配置
```java
@Configuration
@EnableCaching
public class RedisConfig {
    @Bean
    public RedisTemplate<String, Object> redisTemplate(RedisConnectionFactory factory) {
        RedisTemplate<String, Object> template = new RedisTemplate<>();
        template.setConnectionFactory(factory);
        
        // 设置key的序列化方式
        template.setKeySerializer(new StringRedisSerializer());
        
        // 设置value的序列化方式
        Jackson2JsonRedisSerializer<Object> serializer = new Jackson2JsonRedisSerializer<>(Object.class);
        ObjectMapper mapper = new ObjectMapper();
        mapper.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);
        mapper.activateDefaultTyping(LaissezFaireSubTypeValidator.instance, 
            ObjectMapper.DefaultTyping.NON_FINAL);
        serializer.setObjectMapper(mapper);
        template.setValueSerializer(serializer);
        
        return template;
    }
    
    @Bean
    public CacheManager cacheManager(RedisConnectionFactory factory) {
        // 设置缓存过期时间
        RedisCacheConfiguration config = RedisCacheConfiguration.defaultCacheConfig()
                .entryTtl(Duration.ofHours(24))
                .serializeKeysWith(RedisSerializationContext.SerializationPair
                    .fromSerializer(new StringRedisSerializer()))
                .serializeValuesWith(RedisSerializationContext.SerializationPair
                    .fromSerializer(new GenericJackson2JsonRedisSerializer()));
        
        return RedisCacheManager.builder(factory)
                .cacheDefaults(config)
                .build();
    }
}
```

### 26.2 缓存注解使用
```java
@Service
public class ProductServiceImpl implements ProductService {
    @Cacheable(value = "product", key = "#id")
    public ProductDTO getById(Long id) {
        Product product = productMapper.selectById(id);
        return convertToDTO(product);
    }
    
    @CachePut(value = "product", key = "#product.id")
    public ProductDTO update(Product product) {
        productMapper.updateById(product);
        return convertToDTO(product);
    }
    
    @CacheEvict(value = "product", key = "#id")
    public void delete(Long id) {
        productMapper.deleteById(id);
    }
    
    @Cacheable(value = "product", key = "'list:' + #categoryId")
    public List<ProductDTO> listByCategory(Long categoryId) {
        List<Product> products = productMapper.selectByCategoryId(categoryId);
        return convertToDTO(products);
    }
}
```

### 26.3 缓存管理实现
```java
@Service
public class CacheService {
    @Autowired
    private RedisTemplate<String, Object> redisTemplate;
    
    // 设置缓存
    public void set(String key, Object value, long timeout, TimeUnit unit) {
        redisTemplate.opsForValue().set(key, value, timeout, unit);
    }
    
    // 获取缓存
    public <T> T get(String key, Class<T> clazz) {
        Object value = redisTemplate.opsForValue().get(key);
        return value == null ? null : JsonUtil.parseObject(JsonUtil.toJsonString(value), clazz);
    }
    
    // 删除缓存
    public void delete(String key) {
        redisTemplate.delete(key);
    }
    
    // 批量删除缓存
    public void deleteByPattern(String pattern) {
        Set<String> keys = redisTemplate.keys(pattern);
        if (keys != null && !keys.isEmpty()) {
            redisTemplate.delete(keys);
        }
    }
    
    // 设置过期时间
    public boolean expire(String key, long timeout, TimeUnit unit) {
        return Boolean.TRUE.equals(redisTemplate.expire(key, timeout, unit));
    }
    
    // 判断key是否存在
    public boolean hasKey(String key) {
        return Boolean.TRUE.equals(redisTemplate.hasKey(key));
    }
}
```

### 26.4 性能优化实现
1. 数据库优化
   ```sql
   -- 添加合适的索引
   ALTER TABLE product ADD INDEX idx_category_status (category_id, status);
   ALTER TABLE product ADD INDEX idx_name_price (name, price);
   
   -- 优化查询SQL
   SELECT p.*, c.name as category_name
   FROM product p
   FORCE INDEX (idx_category_status)
   LEFT JOIN category c ON p.category_id = c.id
   WHERE p.status = 1
   AND p.category_id = ?
   ORDER BY p.create_time DESC
   LIMIT ?, ?;
   ```

2. 连接池���置
   ```yaml
   spring:
     datasource:
       type: com.zaxxer.hikari.HikariDataSource
       hikari:
         minimum-idle: 5
         maximum-pool-size: 15
         auto-commit: true
         idle-timeout: 30000
         pool-name: HikariCP
         max-lifetime: 1800000
         connection-timeout: 30000
         connection-test-query: SELECT 1
   ```

3. 线程池配置
   ```java
   @Configuration
   public class ThreadPoolConfig {
       @Bean
       public ThreadPoolExecutor threadPoolExecutor() {
           return new ThreadPoolExecutor(
               10,                     // 核心线程数
               20,                    // 最大线程数
               60,                    // 空闲线程存活时间
               TimeUnit.SECONDS,      // 时间单位
               new LinkedBlockingQueue<>(100),  // 任务队列
               new ThreadFactoryBuilder()
                   .setNameFormat("async-service-%d")
                   .build(),          // 线程工厂
               new ThreadPoolExecutor.CallerRunsPolicy()  // 拒绝策略
           );
       }
   }
   ```

### 26.5 异步任务处理
```java
@Service
public class AsyncService {
    @Autowired
    private ThreadPoolExecutor threadPoolExecutor;
    
    // 异步处理订单
    public CompletableFuture<Void> processOrder(Order order) {
        return CompletableFuture.runAsync(() -> {
            try {
                // 1. 更新库存
                updateStock(order);
                
                // 2. 发送通知
                sendNotification(order);
                
                // 3. 更新统计数据
                updateStatistics(order);
            } catch (Exception e) {
                log.error("处理订单异常", e);
                throw new CompletionException(e);
            }
        }, threadPoolExecutor);
    }
    
    // 异步发送消息
    public CompletableFuture<Void> sendMessage(Message message) {
        return CompletableFuture.runAsync(() -> {
            try {
                // 1. 保存消息记录
                saveMessage(message);
                
                // 2. 发送消���
                doSendMessage(message);
                
                // 3. 更新发送状态
                updateMessageStatus(message);
            } catch (Exception e) {
                log.error("发送消息异常", e);
                throw new CompletionException(e);
            }
        }, threadPoolExecutor);
    }
}
```

### 26.6 性能监控实现
1. 接口响应时间监控
   ```java
   @Aspect
   @Component
   public class PerformanceMonitor {
       private static final Logger log = LoggerFactory.getLogger(PerformanceMonitor.class);
       
       @Around("execution(* com.mall.controller.*.*(..))")
       public Object monitorPerformance(ProceedingJoinPoint joinPoint) throws Throwable {
           long startTime = System.currentTimeMillis();
           String methodName = joinPoint.getSignature().getName();
           
           try {
               return joinPoint.proceed();
           } finally {
               long endTime = System.currentTimeMillis();
               long duration = endTime - startTime;
               
               if (duration > 1000) {  // 超过1秒的请求记录警告日志
                   log.warn("方法执行时间过长: {} - {}ms", methodName, duration);
               }
               
               // 记录监控指标
               recordMetrics(methodName, duration);
           }
       }
       
       private void recordMetrics(String methodName, long duration) {
           // 使用Micrometer记录监控指标
           Timer.builder("api.response.time")
               .tag("method", methodName)
               .register(Metrics.globalRegistry)
               .record(duration, TimeUnit.MILLISECONDS);
       }
   }
   ```

2. 缓存命中率监控
   ```java
   @Aspect
   @Component
   public class CacheMonitor {
       private Counter cacheHits;
       private Counter cacheMisses;
       
       @PostConstruct
       public void init() {
           cacheHits = Counter.builder("cache.hits")
               .description("缓存命中次数")
               .register(Metrics.globalRegistry);
               
           cacheMisses = Counter.builder("cache.misses")
               .description("缓存未命中次数")
               .register(Metrics.globalRegistry);
       }
       
       @Around("@annotation(org.springframework.cache.annotation.Cacheable)")
       public Object monitorCache(ProceedingJoinPoint joinPoint) throws Throwable {
           String methodName = joinPoint.getSignature().getName();
           
           // 获取缓存key
           String cacheKey = getCacheKey(joinPoint);
           
           // 检查缓存是否存在
           if (hasCache(cacheKey)) {
               cacheHits.increment();
               log.debug("缓存命中: {} - {}", methodName, cacheKey);
           } else {
               cacheMisses.increment();
               log.debug("缓存未命中: {} - {}", methodName, cacheKey);
           }
           
           return joinPoint.proceed();
       }
   }
   ```

## 27. 日志和监控模块实现

### 27.1 日志配置
```yaml
logging:
  level:
    root: INFO
    com.mall: DEBUG
  file:
    name: logs/mall.log
  pattern:
    console: "%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{50} - %msg%n"
    file: "%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{50} - %msg%n"
```

### 27.2 操作日志实现
```java
@Aspect
@Component
public class OperationLogAspect {
    @Autowired
    private OperationLogMapper operationLogMapper;
    
    @Around("@annotation(com.mall.annotation.OperationLog)")
    public Object around(ProceedingJoinPoint point) throws Throwable {
        long startTime = System.currentTimeMillis();
        Object result = null;
        Exception exception = null;
        
        try {
            result = point.proceed();
            return result;
        } catch (Exception e) {
            exception = e;
            throw e;
        } finally {
            saveOperationLog(point, startTime, result, exception);
        }
    }
    
    private void saveOperationLog(ProceedingJoinPoint point, long startTime, 
                                Object result, Exception exception) {
        try {
            // 获取当前用户
            String username = SecurityContextHolder.getContext()
                .getAuthentication().getName();
            
            // 获取请求信息
            ServletRequestAttributes attributes = (ServletRequestAttributes) 
                RequestContextHolder.getRequestAttributes();
            HttpServletRequest request = attributes.getRequest();
            
            // 获取注解信息
            MethodSignature signature = (MethodSignature) point.getSignature();
            Method method = signature.getMethod();
            OperationLog operationLog = method.getAnnotation(OperationLog.class);
            
            // 构建日志对象
            OperationLogEntity log = new OperationLogEntity();
            log.setUsername(username);
            log.setOperation(operationLog.value());
            log.setMethod(method.getName());
            log.setParams(JsonUtil.toJsonString(point.getArgs()));
            log.setIp(IpUtil.getIpAddr(request));
            log.setUrl(request.getRequestURI());
            log.setDuration(System.currentTimeMillis() - startTime);
            
            if (exception != null) {
                log.setStatus(0);
                log.setError(exception.getMessage());
            } else {
                log.setStatus(1);
                log.setResult(JsonUtil.toJsonString(result));
            }
            
            // 保存日志
            operationLogMapper.insert(log);
        } catch (Exception e) {
            log.error("保存操作日志失败", e);
        }
    }
}
```

### 27.3 系统监控实现
1. 服务器监控
```java
@Service
public class ServerMonitorService {
    public ServerInfo getServerInfo() {
        ServerInfo info = new ServerInfo();
        
        // CPU信息
        SystemInfo si = new SystemInfo();
        CentralProcessor processor = si.getHardware().getProcessor();
        long[] prevTicks = processor.getSystemCpuLoadTicks();
        long[] ticks = processor.getSystemCpuLoadTicks();
        info.setCpuUsage(processor.getSystemCpuLoadBetweenTicks(prevTicks));
        
        // 内存信息
        GlobalMemory memory = si.getHardware().getMemory();
        info.setTotalMemory(memory.getTotal());
        info.setUsedMemory(memory.getTotal() - memory.getAvailable());
        
        // JVM信息
        Runtime runtime = Runtime.getRuntime();
        info.setJvmTotalMemory(runtime.totalMemory());
        info.setJvmFreeMemory(runtime.freeMemory());
        info.setJvmUsedMemory(runtime.totalMemory() - runtime.freeMemory());
        
        return info;
    }
}
```

2. 接口监控
```java
@Configuration
public class MetricsConfig {
    @Bean
    public MeterRegistry meterRegistry() {
        return new SimpleMeterRegistry();
    }
    
    @Bean
    public TimedAspect timedAspect(MeterRegistry registry) {
        return new TimedAspect(registry);
    }
}

@RestController
@Timed(value = "api.requests", 
       extraTags = {"version", "1.0"}, 
       percentiles = {0.5, 0.75, 0.95, 0.99})
public class ProductController {
    @GetMapping("/products")
    public Result<List<ProductDTO>> list() {
        // ...
    }
}
```

### 27.4 告警通知实现
```java
@Service
public class AlertService {
    @Autowired
    private JavaMailSender mailSender;
    
    @Value("${alert.mail.to}")
    private String alertMailTo;
    
    public void sendAlert(String title, String content) {
        try {
            SimpleMailMessage message = new SimpleMailMessage();
            message.setTo(alertMailTo);
            message.setSubject(title);
            message.setText(content);
            mailSender.send(message);
            
            log.info("告警邮件发送成功：{}", title);
        } catch (Exception e) {
            log.error("告警邮件发送失败", e);
        }
    }
    
    @Scheduled(fixedRate = 300000)  // 每5分钟执行一次
    public void checkSystem() {
        // 1. 检查CPU使用率
        double cpuUsage = getCpuUsage();
        if (cpuUsage > 80) {
            sendAlert("CPU告警", 
                String.format("CPU使用率过高：%.2f%%", cpuUsage));
        }
        
        // 2. 检查内存使用率
        double memoryUsage = getMemoryUsage();
        if (memoryUsage > 80) {
            sendAlert("内存告警", 
                String.format("内存使用率过高：%.2f%%", memoryUsage));
        }
        
        // 3. 检查磁盘使用率
        double diskUsage = getDiskUsage();
        if (diskUsage > 80) {
            sendAlert("磁盘告警", 
                String.format("磁盘使用率过高：%.2f%%", diskUsage));
        }
    }
}
```

### 27.5 操作日志表结构
```sql
CREATE TABLE `operation_log` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `username` varchar(50) NOT NULL COMMENT '操作用户',
  `operation` varchar(50) NOT NULL COMMENT '操作内容',
  `method` varchar(100) NOT NULL COMMENT '请求方法',
  `params` text COMMENT '请求参数',
  `ip` varchar(64) NOT NULL COMMENT '操作IP',
  `url` varchar(255) NOT NULL COMMENT '请求URL',
  `duration` bigint(20) NOT NULL COMMENT '执行时长(毫秒)',
  `status` tinyint(4) NOT NULL COMMENT '操作状态：0-失败，1-成功',
  `result` text COMMENT '返回结果',
  `error` text COMMENT '错误信息',
  `create_time` datetime NOT NULL COMMENT '创建时间',
  PRIMARY KEY (`id`),
  KEY `idx_username` (`username`),
  KEY `idx_operation` (`operation`),
  KEY `idx_create_time` (`create_time`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='操作日志表';
```

### 27.6 监控指标说明
1. 系统指标
   - CPU使用率
   - 内存使用率
   - 磁盘使用率
   - JVM堆内存使用情况
   - 线程池状态

2. 业务指标
   - 接口响应时间
   - 接口调用次数
   - 接口错误率
   - 订单转化率
   - 支付成功率

3. 缓存指标
   - 缓存命中率
   - 缓存使用率
   - 缓存响应时间
   - 缓存穿透率

4. 数据库指标
   - 连接池使用率
   - SQL执行时间
   - 慢查询数量
   - 事务成功率

## 28. 消息和通知模块实现

### 28.1 消息配置
```yaml
spring:
  mail:
    host: smtp.qq.com
    port: 465
    username: your-email@qq.com
    password: your-password
    properties:
      mail.smtp.ssl.enable: true
      
  rabbitmq:
    host: localhost
    port: 5672
    username: guest
    password: guest
    virtual-host: /
    listener:
      simple:
        concurrency: 5
        max-concurrency: 10
```

### 28.2 消息生产者实现
```java
@Service
public class MessageProducer {
    @Autowired
    private RabbitTemplate rabbitTemplate;
    
    // 发送订单消息
    public void sendOrderMessage(OrderMessage message) {
        try {
            rabbitTemplate.convertAndSend("order.exchange", "order.create", message);
            log.info("发送订单消息成功：{}", message);
        } catch (Exception e) {
            log.error("发送订单消息失败", e);
            throw new RuntimeException("发送订单消息失败", e);
        }
    }
    
    // 发送支付消息
    public void sendPaymentMessage(PaymentMessage message) {
        try {
            rabbitTemplate.convertAndSend("payment.exchange", "payment.success", message);
            log.info("发送支付消息成功：{}", message);
        } catch (Exception e) {
            log.error("发送支付消息失败", e);
            throw new RuntimeException("发送支付消息失败", e);
        }
    }
    
    // 发送库存消息
    public void sendStockMessage(StockMessage message) {
        try {
            rabbitTemplate.convertAndSend("stock.exchange", "stock.update", message);
            log.info("发送库存消息成功：{}", message);
        } catch (Exception e) {
            log.error("发送库存消息失败", e);
            throw new RuntimeException("发送库存消息失败", e);
        }
    }
}
```

### 28.3 消息消费者实现
```java
@Component
@RabbitListener(queues = "order.queue")
public class OrderMessageConsumer {
    @Autowired
    private OrderService orderService;
    
    @RabbitHandler
    public void handleOrderMessage(OrderMessage message) {
        try {
            log.info("收到订单消息：{}", message);
            
            // 处理订单消息
            orderService.processOrder(message);
            
            log.info("处理订单消息成功");
        } catch (Exception e) {
            log.error("处理订单消息失败", e);
            // 消息处理失败，可以重试或记录失败日志
        }
    }
}

@Component
@RabbitListener(queues = "payment.queue")
public class PaymentMessageConsumer {
    @Autowired
    private PaymentService paymentService;
    
    @RabbitHandler
    public void handlePaymentMessage(PaymentMessage message) {
        try {
            log.info("收到支付消息：{}", message);
            
            // 处理支付消息
            paymentService.processPayment(message);
            
            log.info("处理支付消息成功");
        } catch (Exception e) {
            log.error("处理支付消息失败", e);
        }
    }
}
```

### 28.4 邮件通知实现
```java
@Service
public class EmailService {
    @Autowired
    private JavaMailSender mailSender;
    
    @Value("${spring.mail.username}")
    private String from;
    
    // 发送简单邮件
    public void sendSimpleMail(String to, String subject, String content) {
        try {
            SimpleMailMessage message = new SimpleMailMessage();
            message.setFrom(from);
            message.setTo(to);
            message.setSubject(subject);
            message.setText(content);
            mailSender.send(message);
            
            log.info("发送邮件成功：{}", to);
        } catch (Exception e) {
            log.error("发送邮件失败", e);
            throw new RuntimeException("发送邮件失败", e);
        }
    }
    
    // 发送HTML邮件
    public void sendHtmlMail(String to, String subject, String content) {
        try {
            MimeMessage message = mailSender.createMimeMessage();
            MimeMessageHelper helper = new MimeMessageHelper(message, true);
            helper.setFrom(from);
            helper.setTo(to);
            helper.setSubject(subject);
            helper.setText(content, true);
            mailSender.send(message);
            
            log.info("发送HTML邮件成功：{}", to);
        } catch (Exception e) {
            log.error("发送HTML邮件失败", e);
            throw new RuntimeException("发送HTML邮件失败", e);
        }
    }
}
```

### 28.5 站内消息实现
```java
@Service
public class MessageService {
    @Autowired
    private MessageMapper messageMapper;
    
    // 发送站内消息
    public void sendMessage(Message message) {
        try {
            message.setCreateTime(LocalDateTime.now());
            message.setStatus(0);  // 0-未读
            messageMapper.insert(message);
            
            log.info("发送站内消息成功：{}", message);
        } catch (Exception e) {
            log.error("发送站内消息失败", e);
            throw new RuntimeException("发送站内消息失败", e);
        }
    }
    
    // 获取用户未读消息
    public List<Message> getUnreadMessages(Long userId) {
        return messageMapper.selectUnreadMessages(userId);
    }
    
    // 标记消息为已读
    public void markAsRead(Long messageId) {
        Message message = new Message();
        message.setId(messageId);
        message.setStatus(1);  // 1-已读
        message.setReadTime(LocalDateTime.now());
        messageMapper.updateById(message);
    }
}
```

### 28.6 消息表结构
```sql
CREATE TABLE `message` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `user_id` bigint(20) NOT NULL COMMENT '接收用户ID',
  `type` tinyint(4) NOT NULL COMMENT '消息类型：1-系统消息，2-订单消息，3-支付消息',
  `title` varchar(100) NOT NULL COMMENT '消息标题',
  `content` text NOT NULL COMMENT '消息内容',
  `status` tinyint(4) NOT NULL COMMENT '状态：0-未读，1-已读',
  `read_time` datetime DEFAULT NULL COMMENT '阅读时间',
  `create_time` datetime NOT NULL COMMENT '创建时间',
  PRIMARY KEY (`id`),
  KEY `idx_user_status` (`user_id`, `status`),
  KEY `idx_create_time` (`create_time`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='站内消息表';
```

### 28.7 消息队列配置
```java
@Configuration
public class RabbitConfig {
    // 订单交换机
    @Bean
    public DirectExchange orderExchange() {
        return new DirectExchange("order.exchange");
    }
    
    // 订单队列
    @Bean
    public Queue orderQueue() {
        return new Queue("order.queue");
    }
    
    // 订单绑定
    @Bean
    public Binding orderBinding() {
        return BindingBuilder.bind(orderQueue())
                .to(orderExchange())
                .with("order.create");
    }
    
    // 支付交换机
    @Bean
    public DirectExchange paymentExchange() {
        return new DirectExchange("payment.exchange");
    }
    
    // 支付队列
    @Bean
    public Queue paymentQueue() {
        return new Queue("payment.queue");
    }
    
    // 支付绑定
    @Bean
    public Binding paymentBinding() {
        return BindingBuilder.bind(paymentQueue())
                .to(paymentExchange())
                .with("payment.success");
    }
    
    // 消息转换器
    @Bean
    public MessageConverter messageConverter() {
        return new Jackson2JsonMessageConverter();
    }
}
```

## 29. 定时任务和调度模块实现

### 29.1 定时任务配置
```java
@Configuration
@EnableScheduling
public class ScheduleConfig {
    @Bean
    public TaskScheduler taskScheduler() {
        ThreadPoolTaskScheduler scheduler = new ThreadPoolTaskScheduler();
        scheduler.setPoolSize(10);
        scheduler.setThreadNamePrefix("task-");
        scheduler.setAwaitTerminationSeconds(60);
        scheduler.setWaitForTasksToCompleteOnShutdown(true);
        return scheduler;
    }
}
```

### 29.2 订单超时处理任务
```java
@Component
@Slf4j
public class OrderTimeoutTask {
    @Autowired
    private OrderService orderService;
    
    // 每分钟执行一次
    @Scheduled(fixedRate = 60000)
    public void handleTimeoutOrders() {
        try {
            log.info("开始处理超时订单...");
            
            // 获取超时订单列表
            List<Order> timeoutOrders = orderService.getTimeoutOrders();
            
            // 批量取消超时订单
            for (Order order : timeoutOrders) {
                try {
                    orderService.cancelOrder(order.getId(), "订单超时自动取消");
                    log.info("取消超时订单成功：orderId={}", order.getId());
                } catch (Exception e) {
                    log.error("取消超时订单失败：orderId=" + order.getId(), e);
                }
            }
            
            log.info("处理超时订单完成，共处理{}个订单", timeoutOrders.size());
        } catch (Exception e) {
            log.error("处理超时订单异常", e);
        }
    }
}
```

### 29.3 库存定时更新任务
```java
@Component
@Slf4j
public class StockSyncTask {
    @Autowired
    private ProductService productService;
    
    // 每天凌晨2点执行
    @Scheduled(cron = "0 0 2 * * ?")
    public void syncStock() {
        try {
            log.info("开始同步库存...");
            
            // 获取所有商品
            List<Product> products = productService.getAllProducts();
            
            // 更新库存
            for (Product product : products) {
                try {
                    productService.syncStock(product.getId());
                    log.info("同步商品库存成功：productId={}", product.getId());
                } catch (Exception e) {
                    log.error("同步商品库存失败：productId=" + product.getId(), e);
                }
            }
            
            log.info("同步库存完成，共处理{}个商品", products.size());
        } catch (Exception e) {
            log.error("同步库存异常", e);
        }
    }
}
```

### 29.4 统计数据更新任务
```java
@Component
@Slf4j
public class StatisticsTask {
    @Autowired
    private StatisticsService statisticsService;
    
    // 每小时执行一次
    @Scheduled(fixedRate = 3600000)
    public void updateStatistics() {
        try {
            log.info("开始更新统计数据...");
            
            // 更新订单统计
            statisticsService.updateOrderStatistics();
            
            // 更新商品销量统计
            statisticsService.updateProductSalesStatistics();
            
            // 更新用户统计
            statisticsService.updateUserStatistics();
            
            log.info("更新统计数据完成");
        } catch (Exception e) {
            log.error("更新统计数据异常", e);
        }
    }
}
```

### 29.5 缓存定时清理任务
```java
@Component
@Slf4j
public class CacheCleanTask {
    @Autowired
    private CacheService cacheService;
    
    // 每天凌晨3点执行
    @Scheduled(cron = "0 0 3 * * ?")
    public void cleanCache() {
        try {
            log.info("开始清理缓存...");
            
            // 清理商品缓存
            int productCount = cacheService.cleanProductCache();
            log.info("清理商品缓存完成，共清理{}条", productCount);
            
            // 清理分类缓存
            int categoryCount = cacheService.cleanCategoryCache();
            log.info("清理分类缓存完成，共清理{}条", categoryCount);
            
            // 清理用户缓存
            int userCount = cacheService.cleanUserCache();
            log.info("清理用户缓存完成，共清理{}条", userCount);
            
            log.info("清理缓存完成");
        } catch (Exception e) {
            log.error("清理缓存异常", e);
        }
    }
}
```

### 29.6 定时任务监控
```java
@Aspect
@Component
@Slf4j
public class ScheduleMonitor {
    private static final String MONITOR_PREFIX = "schedule.task.";
    
    @Autowired
    private MeterRegistry registry;
    
    @Around("@annotation(org.springframework.scheduling.annotation.Scheduled)")
    public Object monitorScheduleTask(ProceedingJoinPoint point) throws Throwable {
        String taskName = point.getSignature().getName();
        Timer.Sample sample = Timer.start(registry);
        
        try {
            Counter.builder(MONITOR_PREFIX + "count")
                .tag("task", taskName)
                .register(registry)
                .increment();
            
            return point.proceed();
        } catch (Exception e) {
            Counter.builder(MONITOR_PREFIX + "error")
                .tag("task", taskName)
                .register(registry)
                .increment();
            throw e;
        } finally {
            sample.stop(Timer.builder(MONITOR_PREFIX + "time")
                .tag("task", taskName)
                .register(registry));
        }
    }
}
```

### 29.7 定时任务表结构
```sql
CREATE TABLE `schedule_task` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `task_name` varchar(100) NOT NULL COMMENT '任务名称',
  `task_key` varchar(100) NOT NULL COMMENT '任务标识',
  `task_desc` varchar(255) DEFAULT NULL COMMENT '任务描述',
  `task_cron` varchar(100) NOT NULL COMMENT '任务表达式',
  `status` tinyint(4) NOT NULL DEFAULT '1' COMMENT '状态：0-禁用，1-启用',
  `last_execute_time` datetime DEFAULT NULL COMMENT '上次执行时间',
  `last_execute_result` tinyint(4) DEFAULT NULL COMMENT '上次执行结果：0-失败，1-成功',
  `error_msg` text COMMENT '错误信息',
  `create_time` datetime NOT NULL COMMENT '创建时间',
  `update_time` datetime NOT NULL COMMENT '更新时间',
  PRIMARY KEY (`id`),
  UNIQUE KEY `uk_task_key` (`task_key`),
  KEY `idx_status` (`status`),
  KEY `idx_last_execute_time` (`last_execute_time`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='定时任务表';

CREATE TABLE `schedule_log` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `task_id` bigint(20) NOT NULL COMMENT '任务ID',
  `execute_time` datetime NOT NULL COMMENT '执行时间',
  `duration` bigint(20) NOT NULL COMMENT '执行时长(毫秒)',
  `status` tinyint(4) NOT NULL COMMENT '执行结果：0-失败，1-成功',
  `error_msg` text COMMENT '错误信息',
  PRIMARY KEY (`id`),
  KEY `idx_task_id` (`task_id`),
  KEY `idx_execute_time` (`execute_time`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='定时任务日志表';
```

### 29.8 分布式任务调度
1. 基于Redis分布式锁
```java
@Component
public class DistributedScheduleTask {
    @Autowired
    private StringRedisTemplate redisTemplate;
    
    @Scheduled(fixedRate = 60000)
    public void executeTask() {
        String lockKey = "schedule:task:lock";
        String lockValue = UUID.randomUUID().toString();
        
        try {
            // 尝试获取锁
            Boolean success = redisTemplate.opsForValue()
                .setIfAbsent(lockKey, lockValue, 1, TimeUnit.MINUTES);
            
            if (Boolean.TRUE.equals(success)) {
                // 获取锁成功，执行任务
                doTask();
            }
        } finally {
            // 释放锁
            String value = redisTemplate.opsForValue().get(lockKey);
            if (lockValue.equals(value)) {
                redisTemplate.delete(lockKey);
            }
        }
    }
}
```

2. 基于数据库乐观锁
```java
@Component
public class DatabaseLockTask {
    @Autowired
    private TaskMapper taskMapper;
    
    @Scheduled(fixedRate = 60000)
    public void executeTask() {
        // 查询任务
        Task task = taskMapper.selectByKey("TASK_KEY");
        
        // 更新任务状态（乐观锁）
        int count = taskMapper.updateStatusWithVersion(
            task.getId(), 
            task.getVersion(), 
            TaskStatus.RUNNING.getValue()
        );
        
        if (count > 0) {
            try {
                // 更新成功，执行任务
                doTask();
                
                // 更新任务执行结果
                task.setStatus(TaskStatus.SUCCESS.getValue());
            } catch (Exception e) {
                task.setStatus(TaskStatus.FAILED.getValue());
                task.setErrorMsg(e.getMessage());
            } finally {
                taskMapper.updateById(task);
            }
        }
    }
}
```

